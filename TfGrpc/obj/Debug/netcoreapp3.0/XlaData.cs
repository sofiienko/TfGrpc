// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: tensorflow/compiler/xla/xla_data.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Xla {

  /// <summary>Holder for reflection information generated from tensorflow/compiler/xla/xla_data.proto</summary>
  public static partial class XlaDataReflection {

    #region Descriptor
    /// <summary>File descriptor for tensorflow/compiler/xla/xla_data.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static XlaDataReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "CiZ0ZW5zb3JmbG93L2NvbXBpbGVyL3hsYS94bGFfZGF0YS5wcm90bxIDeGxh",
            "IrcBCg1QYWRkaW5nQ29uZmlnEj0KCmRpbWVuc2lvbnMYASADKAsyKS54bGEu",
            "UGFkZGluZ0NvbmZpZy5QYWRkaW5nQ29uZmlnRGltZW5zaW9uGmcKFlBhZGRp",
            "bmdDb25maWdEaW1lbnNpb24SGAoQZWRnZV9wYWRkaW5nX2xvdxgBIAEoAxIZ",
            "ChFlZGdlX3BhZGRpbmdfaGlnaBgCIAEoAxIYChBpbnRlcmlvcl9wYWRkaW5n",
            "GAMgASgDIh8KCVRpbGVQcm90bxISCgpkaW1lbnNpb25zGAEgAygDIuABCgtM",
            "YXlvdXRQcm90bxIbCgZmb3JtYXQYBCABKA4yCy54bGEuRm9ybWF0EhYKDm1p",
            "bm9yX3RvX21ham9yGAEgAygDEhsKE21heF9zcGFyc2VfZWxlbWVudHMYBSAB",
            "KAMSHQoFdGlsZXMYBiADKAsyDi54bGEuVGlsZVByb3RvEhwKFGVsZW1lbnRf",
            "c2l6ZV9pbl9iaXRzGAcgASgDEhQKDG1lbW9yeV9zcGFjZRgIIAEoA0oECAIQ",
            "A0oECAMQBFIRcGFkZGVkX2RpbWVuc2lvbnNSDXBhZGRpbmdfdmFsdWUivQEK",
            "ClNoYXBlUHJvdG8SKAoMZWxlbWVudF90eXBlGAIgASgOMhIueGxhLlByaW1p",
            "dGl2ZVR5cGUSEgoKZGltZW5zaW9ucxgDIAMoAxIlCgx0dXBsZV9zaGFwZXMY",
            "BCADKAsyDy54bGEuU2hhcGVQcm90bxIgCgZsYXlvdXQYBSABKAsyEC54bGEu",
            "TGF5b3V0UHJvdG8SHAoUaXNfZHluYW1pY19kaW1lbnNpb24YBiADKAhKBAgB",
            "EAJSBHJhbmsicgoRUHJvZ3JhbVNoYXBlUHJvdG8SIwoKcGFyYW1ldGVycxgB",
            "IAMoCzIPLnhsYS5TaGFwZVByb3RvEh8KBnJlc3VsdBgCIAEoCzIPLnhsYS5T",
            "aGFwZVByb3RvEhcKD3BhcmFtZXRlcl9uYW1lcxgDIAMoCSJEChBDb21wdXRh",
            "dGlvblN0YXRzEhIKCmZsb3BfY291bnQYASABKAESHAoUdHJhbnNjZW5kZW50",
            "YWxfY291bnQYAiABKAEiWAoKT3BNZXRhZGF0YRIPCgdvcF90eXBlGAEgASgJ",
            "Eg8KB29wX25hbWUYAiABKAkSEwoLc291cmNlX2ZpbGUYAyABKAkSEwoLc291",
            "cmNlX2xpbmUYBCABKAUi4wEKEEV4ZWN1dGlvblByb2ZpbGUSHQoVY29tcGls",
            "YXRpb25fY2FjaGVfaGl0GAEgASgIEhcKD2NvbXBpbGVfdGltZV9tcxgCIAEo",
            "AxIbChNjb21wdXRlX2N5Y2xlX2NvdW50GAMgASgDEhcKD2NvbXB1dGVfdGlt",
            "ZV9ucxgEIAEoAxIkChxjb21wdXRlX2FuZF90cmFuc2Zlcl90aW1lX25zGAUg",
            "ASgDEiAKGGV4ZWN1dGFibGVfc2l6ZV9pbl9ieXRlcxgGIAEoAxIZChFwcm9m",
            "aWxlX2NhY2hlX2hpdBgHIAEoCCIhCg9FeGVjdXRpb25IYW5kbGUSDgoGaGFu",
            "ZGxlGAEgASgDIiIKEEdsb2JhbERhdGFIYW5kbGUSDgoGaGFuZGxlGAEgASgD",
            "IjQKDERldmljZUhhbmRsZRIOCgZoYW5kbGUYASABKAMSFAoMZGV2aWNlX2Nv",
            "dW50GAIgASgDIrQBCg1DaGFubmVsSGFuZGxlEg4KBmhhbmRsZRgBIAEoAxIs",
            "CgR0eXBlGAIgASgOMh4ueGxhLkNoYW5uZWxIYW5kbGUuQ2hhbm5lbFR5cGUi",
            "ZQoLQ2hhbm5lbFR5cGUSGAoUQ0hBTk5FTF9UWVBFX0lOVkFMSUQQABIUChBE",
            "RVZJQ0VfVE9fREVWSUNFEAESEgoOREVWSUNFX1RPX0hPU1QQAhISCg5IT1NU",
            "X1RPX0RFVklDRRADIsUBChVEZXZpY2VBc3NpZ25tZW50UHJvdG8SFQoNcmVw",
            "bGljYV9jb3VudBgBIAEoBRIZChFjb21wdXRhdGlvbl9jb3VudBgCIAEoBRJJ",
            "ChNjb21wdXRhdGlvbl9kZXZpY2VzGAMgAygLMiwueGxhLkRldmljZUFzc2ln",
            "bm1lbnRQcm90by5Db21wdXRhdGlvbkRldmljZRovChFDb21wdXRhdGlvbkRl",
            "dmljZRIaChJyZXBsaWNhX2RldmljZV9pZHMYASADKAUixAIKDExpdGVyYWxQ",
            "cm90bxIeCgVzaGFwZRgBIAEoCzIPLnhsYS5TaGFwZVByb3RvEg0KBXByZWRz",
            "GAIgAygIEgsKA3M4cxgPIAEoDBILCgN1OHMYAyABKAwSDAoEczMycxgEIAMo",
            "BRIMCgRzNjRzGAUgAygDEgwKBHUzMnMYBiADKA0SDAoEdTY0cxgHIAMoBBIM",
            "CgRmMzJzGAggAygCEgwKBGY2NHMYCSADKAESDAoEYzY0cxgMIAMoAhINCgVj",
            "MTI4cxgSIAMoARIpCg50dXBsZV9saXRlcmFscxgKIAMoCzIRLnhsYS5MaXRl",
            "cmFsUHJvdG8SDAoEZjE2cxgLIAEoDBINCgViZjE2cxgNIAEoDBIMCgR1MTZz",
            "GBAgASgMEgwKBHMxNnMYESABKAwSFgoOc3BhcnNlX2luZGljZXMYDiADKAMi",
            "owEKD1dpbmRvd0RpbWVuc2lvbhIMCgRzaXplGAEgASgDEg4KBnN0cmlkZRgC",
            "IAEoAxITCgtwYWRkaW5nX2xvdxgDIAEoAxIUCgxwYWRkaW5nX2hpZ2gYBCAB",
            "KAMSFwoPd2luZG93X2RpbGF0aW9uGAUgASgDEhUKDWJhc2VfZGlsYXRpb24Y",
            "BiABKAMSFwoPd2luZG93X3JldmVyc2FsGAcgASgIIjIKBldpbmRvdxIoCgpk",
            "aW1lbnNpb25zGAEgAygLMhQueGxhLldpbmRvd0RpbWVuc2lvbiJ+ChZHYXRo",
            "ZXJEaW1lbnNpb25OdW1iZXJzEhMKC29mZnNldF9kaW1zGAEgAygDEhwKFGNv",
            "bGxhcHNlZF9zbGljZV9kaW1zGAIgAygDEhcKD3N0YXJ0X2luZGV4X21hcBgD",
            "IAMoAxIYChBpbmRleF92ZWN0b3JfZGltGAQgASgDIpMBChdTY2F0dGVyRGlt",
            "ZW5zaW9uTnVtYmVycxIaChJ1cGRhdGVfd2luZG93X2RpbXMYASADKAMSHAoU",
            "aW5zZXJ0ZWRfd2luZG93X2RpbXMYAiADKAMSJAocc2NhdHRlcl9kaW1zX3Rv",
            "X29wZXJhbmRfZGltcxgDIAMoAxIYChBpbmRleF92ZWN0b3JfZGltGAQgASgD",
            "ItgCChtDb252b2x1dGlvbkRpbWVuc2lvbk51bWJlcnMSHQoVaW5wdXRfYmF0",
            "Y2hfZGltZW5zaW9uGAcgASgDEh8KF2lucHV0X2ZlYXR1cmVfZGltZW5zaW9u",
            "GAggASgDEiAKGGlucHV0X3NwYXRpYWxfZGltZW5zaW9ucxgLIAMoAxImCh5r",
            "ZXJuZWxfaW5wdXRfZmVhdHVyZV9kaW1lbnNpb24YAyABKAMSJwofa2VybmVs",
            "X291dHB1dF9mZWF0dXJlX2RpbWVuc2lvbhgEIAEoAxIhChlrZXJuZWxfc3Bh",
            "dGlhbF9kaW1lbnNpb25zGAYgAygDEh4KFm91dHB1dF9iYXRjaF9kaW1lbnNp",
            "b24YCSABKAMSIAoYb3V0cHV0X2ZlYXR1cmVfZGltZW5zaW9uGAogASgDEiEK",
            "GW91dHB1dF9zcGF0aWFsX2RpbWVuc2lvbnMYDCADKAMimQEKE0RvdERpbWVu",
            "c2lvbk51bWJlcnMSIgoabGhzX2NvbnRyYWN0aW5nX2RpbWVuc2lvbnMYASAD",
            "KAMSIgoacmhzX2NvbnRyYWN0aW5nX2RpbWVuc2lvbnMYAiADKAMSHAoUbGhz",
            "X2JhdGNoX2RpbWVuc2lvbnMYAyADKAMSHAoUcmhzX2JhdGNoX2RpbWVuc2lv",
            "bnMYBCADKAMi3wEKFlRyaWFuZ3VsYXJTb2x2ZU9wdGlvbnMSEQoJbGVmdF9z",
            "aWRlGAEgASgIEg0KBWxvd2VyGAIgASgIEhUKDXVuaXRfZGlhZ29uYWwYAyAB",
            "KAgSOgoLdHJhbnNwb3NlX2EYBCABKA4yJS54bGEuVHJpYW5ndWxhclNvbHZl",
            "T3B0aW9ucy5UcmFuc3Bvc2UiUAoJVHJhbnNwb3NlEhUKEVRSQU5TUE9TRV9J",
            "TlZBTElEEAASEAoMTk9fVFJBTlNQT1NFEAESDQoJVFJBTlNQT1NFEAISCwoH",
            "QURKT0lOVBADIiAKD0Nob2xlc2t5T3B0aW9ucxINCgVsb3dlchgBIAEoCCJv",
            "ChJGcm9udGVuZEF0dHJpYnV0ZXMSLQoDbWFwGAEgAygLMiAueGxhLkZyb250",
            "ZW5kQXR0cmlidXRlcy5NYXBFbnRyeRoqCghNYXBFbnRyeRILCgNrZXkYASAB",
            "KAkSDQoFdmFsdWUYAiABKAk6AjgBIv8BCgpPcFNoYXJkaW5nEiIKBHR5cGUY",
            "ASABKA4yFC54bGEuT3BTaGFyZGluZy5UeXBlEiMKCnRpbGVfc2hhcGUYAiAB",
            "KAsyDy54bGEuU2hhcGVQcm90bxIiChp0aWxlX2Fzc2lnbm1lbnRfZGltZW5z",
            "aW9ucxgDIAMoAxIfChd0aWxlX2Fzc2lnbm1lbnRfZGV2aWNlcxgEIAMoAxIo",
            "Cg90dXBsZV9zaGFyZGluZ3MYBSADKAsyDy54bGEuT3BTaGFyZGluZyI5CgRU",
            "eXBlEg4KClJFUExJQ0FURUQQABILCgdNQVhJTUFMEAESCQoFVFVQTEUQAhIJ",
            "CgVPVEhFUhADIiMKDFJlcGxpY2FHcm91cBITCgtyZXBsaWNhX2lkcxgBIAMo",
            "AyIuCgxTb3VyY2VUYXJnZXQSDgoGc291cmNlGAEgASgDEg4KBnRhcmdldBgC",
            "IAEoAyJ9Cg9QcmVjaXNpb25Db25maWcSOQoRb3BlcmFuZF9wcmVjaXNpb24Y",
            "ASADKA4yHi54bGEuUHJlY2lzaW9uQ29uZmlnLlByZWNpc2lvbiIvCglQcmVj",
            "aXNpb24SCwoHREVGQVVMVBAAEggKBEhJR0gQARILCgdISUdIRVNUEAIiOgoU",
            "UGFyYW1ldGVyUmVwbGljYXRpb24SIgoacmVwbGljYXRlZF9hdF9sZWFmX2J1",
            "ZmZlcnMYASADKAgiewoWV2hpbGVMb29wQmFja2VuZENvbmZpZxJEChBrbm93",
            "bl90cmlwX2NvdW50GAEgASgLMioueGxhLldoaWxlTG9vcEJhY2tlbmRDb25m",
            "aWcuS25vd25UcmlwQ291bnQaGwoOS25vd25UcmlwQ291bnQSCQoBbhgBIAEo",
            "AyraAQoNUHJpbWl0aXZlVHlwZRIaChZQUklNSVRJVkVfVFlQRV9JTlZBTElE",
            "EAASCAoEUFJFRBABEgYKAlM4EAISBwoDUzE2EAMSBwoDUzMyEAQSBwoDUzY0",
            "EAUSBgoCVTgQBhIHCgNVMTYQBxIHCgNVMzIQCBIHCgNVNjQQCRIHCgNGMTYQ",
            "ChIHCgNGMzIQCxIICgRCRjE2EBASBwoDRjY0EAwSBwoDQzY0EA8SCAoEQzEy",
            "OBASEgkKBVRVUExFEA0SDwoLT1BBUVVFX1RZUEUQDhIJCgVUT0tFThARKjMK",
            "BkZvcm1hdBISCg5JTlZBTElEX0ZPUk1BVBAAEgkKBURFTlNFEAESCgoGU1BB",
            "UlNFEAIqMQoHRmZ0VHlwZRIHCgNGRlQQABIICgRJRkZUEAESCAoEUkZGVBAC",
            "EgkKBUlSRkZUEAMqRgoSUmFuZG9tRGlzdHJpYnV0aW9uEg8KC1JOR19JTlZB",
            "TElEEAASDwoLUk5HX1VOSUZPUk0QARIOCgpSTkdfTk9STUFMEAJCA/gBAWIG",
            "cHJvdG8z"));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { },
          new pbr::GeneratedClrTypeInfo(new[] {typeof(global::Xla.PrimitiveType), typeof(global::Xla.Format), typeof(global::Xla.FftType), typeof(global::Xla.RandomDistribution), }, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Xla.PaddingConfig), global::Xla.PaddingConfig.Parser, new[]{ "Dimensions" }, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Xla.PaddingConfig.Types.PaddingConfigDimension), global::Xla.PaddingConfig.Types.PaddingConfigDimension.Parser, new[]{ "EdgePaddingLow", "EdgePaddingHigh", "InteriorPadding" }, null, null, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Xla.TileProto), global::Xla.TileProto.Parser, new[]{ "Dimensions" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Xla.LayoutProto), global::Xla.LayoutProto.Parser, new[]{ "Format", "MinorToMajor", "MaxSparseElements", "Tiles", "ElementSizeInBits", "MemorySpace" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Xla.ShapeProto), global::Xla.ShapeProto.Parser, new[]{ "ElementType", "Dimensions", "TupleShapes", "Layout", "IsDynamicDimension" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Xla.ProgramShapeProto), global::Xla.ProgramShapeProto.Parser, new[]{ "Parameters", "Result", "ParameterNames" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Xla.ComputationStats), global::Xla.ComputationStats.Parser, new[]{ "FlopCount", "TranscendentalCount" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Xla.OpMetadata), global::Xla.OpMetadata.Parser, new[]{ "OpType", "OpName", "SourceFile", "SourceLine" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Xla.ExecutionProfile), global::Xla.ExecutionProfile.Parser, new[]{ "CompilationCacheHit", "CompileTimeMs", "ComputeCycleCount", "ComputeTimeNs", "ComputeAndTransferTimeNs", "ExecutableSizeInBytes", "ProfileCacheHit" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Xla.ExecutionHandle), global::Xla.ExecutionHandle.Parser, new[]{ "Handle" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Xla.GlobalDataHandle), global::Xla.GlobalDataHandle.Parser, new[]{ "Handle" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Xla.DeviceHandle), global::Xla.DeviceHandle.Parser, new[]{ "Handle", "DeviceCount" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Xla.ChannelHandle), global::Xla.ChannelHandle.Parser, new[]{ "Handle", "Type" }, null, new[]{ typeof(global::Xla.ChannelHandle.Types.ChannelType) }, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Xla.DeviceAssignmentProto), global::Xla.DeviceAssignmentProto.Parser, new[]{ "ReplicaCount", "ComputationCount", "ComputationDevices" }, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Xla.DeviceAssignmentProto.Types.ComputationDevice), global::Xla.DeviceAssignmentProto.Types.ComputationDevice.Parser, new[]{ "ReplicaDeviceIds" }, null, null, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Xla.LiteralProto), global::Xla.LiteralProto.Parser, new[]{ "Shape", "Preds", "S8S", "U8S", "S32S", "S64S", "U32S", "U64S", "F32S", "F64S", "C64S", "C128S", "TupleLiterals", "F16S", "Bf16S", "U16S", "S16S", "SparseIndices" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Xla.WindowDimension), global::Xla.WindowDimension.Parser, new[]{ "Size", "Stride", "PaddingLow", "PaddingHigh", "WindowDilation", "BaseDilation", "WindowReversal" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Xla.Window), global::Xla.Window.Parser, new[]{ "Dimensions" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Xla.GatherDimensionNumbers), global::Xla.GatherDimensionNumbers.Parser, new[]{ "OffsetDims", "CollapsedSliceDims", "StartIndexMap", "IndexVectorDim" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Xla.ScatterDimensionNumbers), global::Xla.ScatterDimensionNumbers.Parser, new[]{ "UpdateWindowDims", "InsertedWindowDims", "ScatterDimsToOperandDims", "IndexVectorDim" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Xla.ConvolutionDimensionNumbers), global::Xla.ConvolutionDimensionNumbers.Parser, new[]{ "InputBatchDimension", "InputFeatureDimension", "InputSpatialDimensions", "KernelInputFeatureDimension", "KernelOutputFeatureDimension", "KernelSpatialDimensions", "OutputBatchDimension", "OutputFeatureDimension", "OutputSpatialDimensions" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Xla.DotDimensionNumbers), global::Xla.DotDimensionNumbers.Parser, new[]{ "LhsContractingDimensions", "RhsContractingDimensions", "LhsBatchDimensions", "RhsBatchDimensions" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Xla.TriangularSolveOptions), global::Xla.TriangularSolveOptions.Parser, new[]{ "LeftSide", "Lower", "UnitDiagonal", "TransposeA" }, null, new[]{ typeof(global::Xla.TriangularSolveOptions.Types.Transpose) }, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Xla.CholeskyOptions), global::Xla.CholeskyOptions.Parser, new[]{ "Lower" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Xla.FrontendAttributes), global::Xla.FrontendAttributes.Parser, new[]{ "Map" }, null, null, new pbr::GeneratedClrTypeInfo[] { null, }),
            new pbr::GeneratedClrTypeInfo(typeof(global::Xla.OpSharding), global::Xla.OpSharding.Parser, new[]{ "Type", "TileShape", "TileAssignmentDimensions", "TileAssignmentDevices", "TupleShardings" }, null, new[]{ typeof(global::Xla.OpSharding.Types.Type) }, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Xla.ReplicaGroup), global::Xla.ReplicaGroup.Parser, new[]{ "ReplicaIds" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Xla.SourceTarget), global::Xla.SourceTarget.Parser, new[]{ "Source", "Target" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Xla.PrecisionConfig), global::Xla.PrecisionConfig.Parser, new[]{ "OperandPrecision" }, null, new[]{ typeof(global::Xla.PrecisionConfig.Types.Precision) }, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Xla.ParameterReplication), global::Xla.ParameterReplication.Parser, new[]{ "ReplicatedAtLeafBuffers" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Xla.WhileLoopBackendConfig), global::Xla.WhileLoopBackendConfig.Parser, new[]{ "KnownTripCount" }, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Xla.WhileLoopBackendConfig.Types.KnownTripCount), global::Xla.WhileLoopBackendConfig.Types.KnownTripCount.Parser, new[]{ "N" }, null, null, null)})
          }));
    }
    #endregion

  }
  #region Enums
  /// <summary>
  /// Primitive types are the individual values that can be held in rectangular
  /// multidimensional arrays. A description of the rectangular multidimensional
  /// array dimensions / primitive type is given by Shape, below.
  /// </summary>
  public enum PrimitiveType {
    /// <summary>
    /// Invalid primitive type to serve as default.
    /// </summary>
    [pbr::OriginalName("PRIMITIVE_TYPE_INVALID")] Invalid = 0,
    /// <summary>
    /// Predicates are two-state booleans.
    /// </summary>
    [pbr::OriginalName("PRED")] Pred = 1,
    /// <summary>
    /// Signed integral values of fixed width.
    /// </summary>
    [pbr::OriginalName("S8")] S8 = 2,
    [pbr::OriginalName("S16")] S16 = 3,
    [pbr::OriginalName("S32")] S32 = 4,
    [pbr::OriginalName("S64")] S64 = 5,
    /// <summary>
    /// Unsigned integral values of fixed width.
    /// </summary>
    [pbr::OriginalName("U8")] U8 = 6,
    [pbr::OriginalName("U16")] U16 = 7,
    [pbr::OriginalName("U32")] U32 = 8,
    [pbr::OriginalName("U64")] U64 = 9,
    /// <summary>
    /// Floating-point values of fixed width.
    ///
    /// Note: if f16s are not natively supported on the device, they will be
    /// converted to f16 from f32 at arbirary points in the computation.
    /// </summary>
    [pbr::OriginalName("F16")] F16 = 10,
    [pbr::OriginalName("F32")] F32 = 11,
    /// <summary>
    /// Truncated 16 bit floating-point format. This is similar to IEEE's 16 bit
    /// floating-point format, but uses 1 bit for the sign, 8 bits for the exponent
    /// and 7 bits for the mantissa.
    /// </summary>
    [pbr::OriginalName("BF16")] Bf16 = 16,
    [pbr::OriginalName("F64")] F64 = 12,
    /// <summary>
    /// Complex values of fixed width.
    /// </summary>
    [pbr::OriginalName("C64")] C64 = 15,
    /// <summary>
    /// Paired F64 (real, imag), as in std::complex&lt;double>.
    /// </summary>
    [pbr::OriginalName("C128")] C128 = 18,
    /// <summary>
    /// A tuple is a polymorphic sequence; e.g. a shape that holds different
    /// sub-shapes. They are used for things like returning multiple values from a
    /// computation; e.g. a computation that returns weights and biases may have a
    /// signature that results in a tuple like (f32[784x2000], f32[2000])
    ///
    /// If a shape proto has the tuple element type, it may not have any entries
    /// in the dimensions field.
    /// </summary>
    [pbr::OriginalName("TUPLE")] Tuple = 13,
    /// <summary>
    /// An opaque type used for passing context-specific data to a custom
    /// operation. Shapes of this primitive type will have empty dimensions and
    /// tuple_shapes fields.
    ///
    /// (OPAQUE would be a better name for this identifier, but that conflicts with
    /// a macro defined in windows.h.)
    /// </summary>
    [pbr::OriginalName("OPAQUE_TYPE")] OpaqueType = 14,
    /// <summary>
    /// A token type threaded between side-effecting operations. Shapes of this
    /// primitive type will have empty dimensions and tuple_shapes fields.
    /// </summary>
    [pbr::OriginalName("TOKEN")] Token = 17,
  }

  /// <summary>
  /// A format specifies the method used by a layout to store an array in memory.
  /// </summary>
  public enum Format {
    /// <summary>
    /// TODO(b/120869032): Rename this to FORMAT_NONE or something else which
    /// better corresponds to its meaning.
    /// </summary>
    [pbr::OriginalName("INVALID_FORMAT")] InvalidFormat = 0,
    /// <summary>
    /// The default layout, with exactly one storage location per element.
    /// </summary>
    [pbr::OriginalName("DENSE")] Dense = 1,
    /// <summary>
    /// A sparsely encoded layout, providing only the index/value pairs of non-zero
    /// elements.
    /// </summary>
    [pbr::OriginalName("SPARSE")] Sparse = 2,
  }

  public enum FftType {
    /// <summary>
    /// Forward FFT; complex in, complex out.
    /// </summary>
    [pbr::OriginalName("FFT")] Fft = 0,
    /// <summary>
    /// Inverse FFT; complex in, complex out.
    /// </summary>
    [pbr::OriginalName("IFFT")] Ifft = 1,
    /// <summary>
    /// Forward real FFT; real in, fft_length / 2 + 1 complex out
    /// </summary>
    [pbr::OriginalName("RFFT")] Rfft = 2,
    /// <summary>
    /// Inverse real FFT; fft_length / 2 + 1 complex in,
    /// </summary>
    [pbr::OriginalName("IRFFT")] Irfft = 3,
  }

  public enum RandomDistribution {
    [pbr::OriginalName("RNG_INVALID")] RngInvalid = 0,
    /// <summary>
    /// Creates a uniform-distribution-generated random number on the semi-open
    /// interval [parameter[0], parameter[1]).
    /// </summary>
    [pbr::OriginalName("RNG_UNIFORM")] RngUniform = 1,
    /// <summary>
    /// Creates a normal-distribution-generated random number with mean
    /// parameter[0] and standard deviation parameter[1].
    /// </summary>
    [pbr::OriginalName("RNG_NORMAL")] RngNormal = 2,
  }

  #endregion

  #region Messages
  /// <summary>
  /// Describes the padding configuration for Pad operation. The padding amount on
  /// both edges as well as between the elements are specified for each dimension.
  /// </summary>
  public sealed partial class PaddingConfig : pb::IMessage<PaddingConfig> {
    private static readonly pb::MessageParser<PaddingConfig> _parser = new pb::MessageParser<PaddingConfig>(() => new PaddingConfig());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<PaddingConfig> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Xla.XlaDataReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public PaddingConfig() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public PaddingConfig(PaddingConfig other) : this() {
      dimensions_ = other.dimensions_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public PaddingConfig Clone() {
      return new PaddingConfig(this);
    }

    /// <summary>Field number for the "dimensions" field.</summary>
    public const int DimensionsFieldNumber = 1;
    private static readonly pb::FieldCodec<global::Xla.PaddingConfig.Types.PaddingConfigDimension> _repeated_dimensions_codec
        = pb::FieldCodec.ForMessage(10, global::Xla.PaddingConfig.Types.PaddingConfigDimension.Parser);
    private readonly pbc::RepeatedField<global::Xla.PaddingConfig.Types.PaddingConfigDimension> dimensions_ = new pbc::RepeatedField<global::Xla.PaddingConfig.Types.PaddingConfigDimension>();
    /// <summary>
    /// The padding configuration for all dimensions.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Xla.PaddingConfig.Types.PaddingConfigDimension> Dimensions {
      get { return dimensions_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as PaddingConfig);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(PaddingConfig other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!dimensions_.Equals(other.dimensions_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= dimensions_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      dimensions_.WriteTo(output, _repeated_dimensions_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      size += dimensions_.CalculateSize(_repeated_dimensions_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(PaddingConfig other) {
      if (other == null) {
        return;
      }
      dimensions_.Add(other.dimensions_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            dimensions_.AddEntriesFrom(input, _repeated_dimensions_codec);
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the PaddingConfig message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      /// <summary>
      /// Describes the padding configuration for a dimension.
      /// </summary>
      public sealed partial class PaddingConfigDimension : pb::IMessage<PaddingConfigDimension> {
        private static readonly pb::MessageParser<PaddingConfigDimension> _parser = new pb::MessageParser<PaddingConfigDimension>(() => new PaddingConfigDimension());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<PaddingConfigDimension> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Xla.PaddingConfig.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public PaddingConfigDimension() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public PaddingConfigDimension(PaddingConfigDimension other) : this() {
          edgePaddingLow_ = other.edgePaddingLow_;
          edgePaddingHigh_ = other.edgePaddingHigh_;
          interiorPadding_ = other.interiorPadding_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public PaddingConfigDimension Clone() {
          return new PaddingConfigDimension(this);
        }

        /// <summary>Field number for the "edge_padding_low" field.</summary>
        public const int EdgePaddingLowFieldNumber = 1;
        private long edgePaddingLow_;
        /// <summary>
        /// Padding amount on the low-end (next to the index 0). May be negative.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public long EdgePaddingLow {
          get { return edgePaddingLow_; }
          set {
            edgePaddingLow_ = value;
          }
        }

        /// <summary>Field number for the "edge_padding_high" field.</summary>
        public const int EdgePaddingHighFieldNumber = 2;
        private long edgePaddingHigh_;
        /// <summary>
        /// Padding amount on the high-end (next to the highest index). May be
        /// negative.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public long EdgePaddingHigh {
          get { return edgePaddingHigh_; }
          set {
            edgePaddingHigh_ = value;
          }
        }

        /// <summary>Field number for the "interior_padding" field.</summary>
        public const int InteriorPaddingFieldNumber = 3;
        private long interiorPadding_;
        /// <summary>
        /// Padding amount between the elements. May not be negative.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public long InteriorPadding {
          get { return interiorPadding_; }
          set {
            interiorPadding_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as PaddingConfigDimension);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(PaddingConfigDimension other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (EdgePaddingLow != other.EdgePaddingLow) return false;
          if (EdgePaddingHigh != other.EdgePaddingHigh) return false;
          if (InteriorPadding != other.InteriorPadding) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (EdgePaddingLow != 0L) hash ^= EdgePaddingLow.GetHashCode();
          if (EdgePaddingHigh != 0L) hash ^= EdgePaddingHigh.GetHashCode();
          if (InteriorPadding != 0L) hash ^= InteriorPadding.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (EdgePaddingLow != 0L) {
            output.WriteRawTag(8);
            output.WriteInt64(EdgePaddingLow);
          }
          if (EdgePaddingHigh != 0L) {
            output.WriteRawTag(16);
            output.WriteInt64(EdgePaddingHigh);
          }
          if (InteriorPadding != 0L) {
            output.WriteRawTag(24);
            output.WriteInt64(InteriorPadding);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (EdgePaddingLow != 0L) {
            size += 1 + pb::CodedOutputStream.ComputeInt64Size(EdgePaddingLow);
          }
          if (EdgePaddingHigh != 0L) {
            size += 1 + pb::CodedOutputStream.ComputeInt64Size(EdgePaddingHigh);
          }
          if (InteriorPadding != 0L) {
            size += 1 + pb::CodedOutputStream.ComputeInt64Size(InteriorPadding);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(PaddingConfigDimension other) {
          if (other == null) {
            return;
          }
          if (other.EdgePaddingLow != 0L) {
            EdgePaddingLow = other.EdgePaddingLow;
          }
          if (other.EdgePaddingHigh != 0L) {
            EdgePaddingHigh = other.EdgePaddingHigh;
          }
          if (other.InteriorPadding != 0L) {
            InteriorPadding = other.InteriorPadding;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 8: {
                EdgePaddingLow = input.ReadInt64();
                break;
              }
              case 16: {
                EdgePaddingHigh = input.ReadInt64();
                break;
              }
              case 24: {
                InteriorPadding = input.ReadInt64();
                break;
              }
            }
          }
        }

      }

    }
    #endregion

  }

  /// <summary>
  /// Describes a tile used in tiling-based layout. Refer to
  /// g3doc/third_party/tensorflow/compiler/xla/g3doc/layout_with_tiling.md for
  /// details about tiling-based layout.
  /// </summary>
  public sealed partial class TileProto : pb::IMessage<TileProto> {
    private static readonly pb::MessageParser<TileProto> _parser = new pb::MessageParser<TileProto>(() => new TileProto());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<TileProto> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Xla.XlaDataReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TileProto() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TileProto(TileProto other) : this() {
      dimensions_ = other.dimensions_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TileProto Clone() {
      return new TileProto(this);
    }

    /// <summary>Field number for the "dimensions" field.</summary>
    public const int DimensionsFieldNumber = 1;
    private static readonly pb::FieldCodec<long> _repeated_dimensions_codec
        = pb::FieldCodec.ForInt64(10);
    private readonly pbc::RepeatedField<long> dimensions_ = new pbc::RepeatedField<long>();
    /// <summary>
    /// Number of elements in each dimension of the tile. It's ordered from the
    /// most major dimension of the tile to the most minor dimension of the tile.
    /// The dimensions correspond to a suffix of the dimensions of the shape being
    /// tiled.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<long> Dimensions {
      get { return dimensions_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as TileProto);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(TileProto other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!dimensions_.Equals(other.dimensions_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= dimensions_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      dimensions_.WriteTo(output, _repeated_dimensions_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      size += dimensions_.CalculateSize(_repeated_dimensions_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(TileProto other) {
      if (other == null) {
        return;
      }
      dimensions_.Add(other.dimensions_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10:
          case 8: {
            dimensions_.AddEntriesFrom(input, _repeated_dimensions_codec);
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// A layout describes how the array is placed in (1D) memory space.  This
  /// includes the minor-to-major ordering of dimensions within a shape.
  ///
  /// Clients must specify the layouts of input Literals to the
  /// computation. Layouts specified in interior operations which take Shapes (for
  /// example, Convert) are ignored.
  ///
  /// See the XLA documentation for more information on shapes and layouts.
  ///
  /// LINT.IfChange
  /// </summary>
  public sealed partial class LayoutProto : pb::IMessage<LayoutProto> {
    private static readonly pb::MessageParser<LayoutProto> _parser = new pb::MessageParser<LayoutProto>(() => new LayoutProto());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<LayoutProto> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Xla.XlaDataReflection.Descriptor.MessageTypes[2]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public LayoutProto() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public LayoutProto(LayoutProto other) : this() {
      format_ = other.format_;
      minorToMajor_ = other.minorToMajor_.Clone();
      maxSparseElements_ = other.maxSparseElements_;
      tiles_ = other.tiles_.Clone();
      elementSizeInBits_ = other.elementSizeInBits_;
      memorySpace_ = other.memorySpace_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public LayoutProto Clone() {
      return new LayoutProto(this);
    }

    /// <summary>Field number for the "format" field.</summary>
    public const int FormatFieldNumber = 4;
    private global::Xla.Format format_ = 0;
    /// <summary>
    /// The method used to store the data in memory. The format determines which of
    /// the other fields are used by the layout.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Xla.Format Format {
      get { return format_; }
      set {
        format_ = value;
      }
    }

    /// <summary>Field number for the "minor_to_major" field.</summary>
    public const int MinorToMajorFieldNumber = 1;
    private static readonly pb::FieldCodec<long> _repeated_minorToMajor_codec
        = pb::FieldCodec.ForInt64(10);
    private readonly pbc::RepeatedField<long> minorToMajor_ = new pbc::RepeatedField<long>();
    /// <summary>
    /// Sequence of dimension numbers, from minor (fastest varying index) to major
    /// (slowest varying index). This field is required.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<long> MinorToMajor {
      get { return minorToMajor_; }
    }

    /// <summary>Field number for the "max_sparse_elements" field.</summary>
    public const int MaxSparseElementsFieldNumber = 5;
    private long maxSparseElements_;
    /// <summary>
    /// The maximum number of elements that can be stored for SPARSE formats.  This
    /// can be used to determine the maximum size in bytes of arrays stored in
    /// memory.  This field must be unset unless the format is SPARSE.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long MaxSparseElements {
      get { return maxSparseElements_; }
      set {
        maxSparseElements_ = value;
      }
    }

    /// <summary>Field number for the "tiles" field.</summary>
    public const int TilesFieldNumber = 6;
    private static readonly pb::FieldCodec<global::Xla.TileProto> _repeated_tiles_codec
        = pb::FieldCodec.ForMessage(50, global::Xla.TileProto.Parser);
    private readonly pbc::RepeatedField<global::Xla.TileProto> tiles_ = new pbc::RepeatedField<global::Xla.TileProto>();
    /// <summary>
    /// A sequence of tiles, starting from the tile that's applied first to the
    /// Shape.
    ///
    /// TODO(b/119839262): implement tiling in each backend or add Unimplemented
    /// error.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Xla.TileProto> Tiles {
      get { return tiles_; }
    }

    /// <summary>Field number for the "element_size_in_bits" field.</summary>
    public const int ElementSizeInBitsFieldNumber = 7;
    private long elementSizeInBits_;
    /// <summary>
    /// Bit size of each element. If the size is bigger than what the element
    /// type requires, the value is stored in the least significant
    /// bits and the additional most significant bits are filled with 0's.
    ///
    /// TODO(b/119839262): implement in each backend or add Unimplemented error.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long ElementSizeInBits {
      get { return elementSizeInBits_; }
      set {
        elementSizeInBits_ = value;
      }
    }

    /// <summary>Field number for the "memory_space" field.</summary>
    public const int MemorySpaceFieldNumber = 8;
    private long memorySpace_;
    /// <summary>
    /// Memory space where this array resides. The integer field is interpreted in
    /// a backend-specific manner.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long MemorySpace {
      get { return memorySpace_; }
      set {
        memorySpace_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as LayoutProto);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(LayoutProto other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Format != other.Format) return false;
      if(!minorToMajor_.Equals(other.minorToMajor_)) return false;
      if (MaxSparseElements != other.MaxSparseElements) return false;
      if(!tiles_.Equals(other.tiles_)) return false;
      if (ElementSizeInBits != other.ElementSizeInBits) return false;
      if (MemorySpace != other.MemorySpace) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Format != 0) hash ^= Format.GetHashCode();
      hash ^= minorToMajor_.GetHashCode();
      if (MaxSparseElements != 0L) hash ^= MaxSparseElements.GetHashCode();
      hash ^= tiles_.GetHashCode();
      if (ElementSizeInBits != 0L) hash ^= ElementSizeInBits.GetHashCode();
      if (MemorySpace != 0L) hash ^= MemorySpace.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      minorToMajor_.WriteTo(output, _repeated_minorToMajor_codec);
      if (Format != 0) {
        output.WriteRawTag(32);
        output.WriteEnum((int) Format);
      }
      if (MaxSparseElements != 0L) {
        output.WriteRawTag(40);
        output.WriteInt64(MaxSparseElements);
      }
      tiles_.WriteTo(output, _repeated_tiles_codec);
      if (ElementSizeInBits != 0L) {
        output.WriteRawTag(56);
        output.WriteInt64(ElementSizeInBits);
      }
      if (MemorySpace != 0L) {
        output.WriteRawTag(64);
        output.WriteInt64(MemorySpace);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Format != 0) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Format);
      }
      size += minorToMajor_.CalculateSize(_repeated_minorToMajor_codec);
      if (MaxSparseElements != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(MaxSparseElements);
      }
      size += tiles_.CalculateSize(_repeated_tiles_codec);
      if (ElementSizeInBits != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(ElementSizeInBits);
      }
      if (MemorySpace != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(MemorySpace);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(LayoutProto other) {
      if (other == null) {
        return;
      }
      if (other.Format != 0) {
        Format = other.Format;
      }
      minorToMajor_.Add(other.minorToMajor_);
      if (other.MaxSparseElements != 0L) {
        MaxSparseElements = other.MaxSparseElements;
      }
      tiles_.Add(other.tiles_);
      if (other.ElementSizeInBits != 0L) {
        ElementSizeInBits = other.ElementSizeInBits;
      }
      if (other.MemorySpace != 0L) {
        MemorySpace = other.MemorySpace;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10:
          case 8: {
            minorToMajor_.AddEntriesFrom(input, _repeated_minorToMajor_codec);
            break;
          }
          case 32: {
            Format = (global::Xla.Format) input.ReadEnum();
            break;
          }
          case 40: {
            MaxSparseElements = input.ReadInt64();
            break;
          }
          case 50: {
            tiles_.AddEntriesFrom(input, _repeated_tiles_codec);
            break;
          }
          case 56: {
            ElementSizeInBits = input.ReadInt64();
            break;
          }
          case 64: {
            MemorySpace = input.ReadInt64();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// A shape describes the number of dimensions in the array, the size of each
  /// dimension, and the primitive component type.
  ///
  /// Tuples are a special case in that they have rank zero and have tuple_shapes
  /// defined.
  ///
  /// See the XLA documentation for more information on shapes and layouts.
  ///
  /// LINT.IfChange
  /// </summary>
  public sealed partial class ShapeProto : pb::IMessage<ShapeProto> {
    private static readonly pb::MessageParser<ShapeProto> _parser = new pb::MessageParser<ShapeProto>(() => new ShapeProto());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ShapeProto> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Xla.XlaDataReflection.Descriptor.MessageTypes[3]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ShapeProto() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ShapeProto(ShapeProto other) : this() {
      elementType_ = other.elementType_;
      dimensions_ = other.dimensions_.Clone();
      tupleShapes_ = other.tupleShapes_.Clone();
      layout_ = other.layout_ != null ? other.layout_.Clone() : null;
      isDynamicDimension_ = other.isDynamicDimension_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ShapeProto Clone() {
      return new ShapeProto(this);
    }

    /// <summary>Field number for the "element_type" field.</summary>
    public const int ElementTypeFieldNumber = 2;
    private global::Xla.PrimitiveType elementType_ = 0;
    /// <summary>
    /// The element type for this shape.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Xla.PrimitiveType ElementType {
      get { return elementType_; }
      set {
        elementType_ = value;
      }
    }

    /// <summary>Field number for the "dimensions" field.</summary>
    public const int DimensionsFieldNumber = 3;
    private static readonly pb::FieldCodec<long> _repeated_dimensions_codec
        = pb::FieldCodec.ForInt64(26);
    private readonly pbc::RepeatedField<long> dimensions_ = new pbc::RepeatedField<long>();
    /// <summary>
    /// The size (number of elements) for each dimension, or an upper bound on the
    /// size if the dimension is dynamic.  In XLA, dimensions are numbered from 0
    /// to N-1 for an N-dimensional array. The first element of 'dimensions' is the
    /// size of dimension 0, the second element is the size of dimension 1, and so
    /// forth.  Empty list indicates a scalar.
    ///
    /// If the respective element in 'is_dimension_dynamic' is true then the value
    /// in this field represents an upper bound on the size of the dimension.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<long> Dimensions {
      get { return dimensions_; }
    }

    /// <summary>Field number for the "tuple_shapes" field.</summary>
    public const int TupleShapesFieldNumber = 4;
    private static readonly pb::FieldCodec<global::Xla.ShapeProto> _repeated_tupleShapes_codec
        = pb::FieldCodec.ForMessage(34, global::Xla.ShapeProto.Parser);
    private readonly pbc::RepeatedField<global::Xla.ShapeProto> tupleShapes_ = new pbc::RepeatedField<global::Xla.ShapeProto>();
    /// <summary>
    /// For tuples only, the shapes of constituent shapes in the tuple sequence.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Xla.ShapeProto> TupleShapes {
      get { return tupleShapes_; }
    }

    /// <summary>Field number for the "layout" field.</summary>
    public const int LayoutFieldNumber = 5;
    private global::Xla.LayoutProto layout_;
    /// <summary>
    /// The layout used to back this shape.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Xla.LayoutProto Layout {
      get { return layout_; }
      set {
        layout_ = value;
      }
    }

    /// <summary>Field number for the "is_dynamic_dimension" field.</summary>
    public const int IsDynamicDimensionFieldNumber = 6;
    private static readonly pb::FieldCodec<bool> _repeated_isDynamicDimension_codec
        = pb::FieldCodec.ForBool(50);
    private readonly pbc::RepeatedField<bool> isDynamicDimension_ = new pbc::RepeatedField<bool>();
    /// <summary>
    /// For arrays, this indicates whether or not each dimension is
    /// dynamically-sized. The number of elements in this repeated field should be
    /// zero (indicating that no dimensions are dynamic) or equal to the number of
    /// elements in the 'dimensions' field.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<bool> IsDynamicDimension {
      get { return isDynamicDimension_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ShapeProto);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ShapeProto other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (ElementType != other.ElementType) return false;
      if(!dimensions_.Equals(other.dimensions_)) return false;
      if(!tupleShapes_.Equals(other.tupleShapes_)) return false;
      if (!object.Equals(Layout, other.Layout)) return false;
      if(!isDynamicDimension_.Equals(other.isDynamicDimension_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (ElementType != 0) hash ^= ElementType.GetHashCode();
      hash ^= dimensions_.GetHashCode();
      hash ^= tupleShapes_.GetHashCode();
      if (layout_ != null) hash ^= Layout.GetHashCode();
      hash ^= isDynamicDimension_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (ElementType != 0) {
        output.WriteRawTag(16);
        output.WriteEnum((int) ElementType);
      }
      dimensions_.WriteTo(output, _repeated_dimensions_codec);
      tupleShapes_.WriteTo(output, _repeated_tupleShapes_codec);
      if (layout_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(Layout);
      }
      isDynamicDimension_.WriteTo(output, _repeated_isDynamicDimension_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (ElementType != 0) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) ElementType);
      }
      size += dimensions_.CalculateSize(_repeated_dimensions_codec);
      size += tupleShapes_.CalculateSize(_repeated_tupleShapes_codec);
      if (layout_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Layout);
      }
      size += isDynamicDimension_.CalculateSize(_repeated_isDynamicDimension_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ShapeProto other) {
      if (other == null) {
        return;
      }
      if (other.ElementType != 0) {
        ElementType = other.ElementType;
      }
      dimensions_.Add(other.dimensions_);
      tupleShapes_.Add(other.tupleShapes_);
      if (other.layout_ != null) {
        if (layout_ == null) {
          Layout = new global::Xla.LayoutProto();
        }
        Layout.MergeFrom(other.Layout);
      }
      isDynamicDimension_.Add(other.isDynamicDimension_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 16: {
            ElementType = (global::Xla.PrimitiveType) input.ReadEnum();
            break;
          }
          case 26:
          case 24: {
            dimensions_.AddEntriesFrom(input, _repeated_dimensions_codec);
            break;
          }
          case 34: {
            tupleShapes_.AddEntriesFrom(input, _repeated_tupleShapes_codec);
            break;
          }
          case 42: {
            if (layout_ == null) {
              Layout = new global::Xla.LayoutProto();
            }
            input.ReadMessage(Layout);
            break;
          }
          case 50:
          case 48: {
            isDynamicDimension_.AddEntriesFrom(input, _repeated_isDynamicDimension_codec);
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// Shape of the parameters and output of a computation (like a traditional
  /// function signature).
  /// </summary>
  public sealed partial class ProgramShapeProto : pb::IMessage<ProgramShapeProto> {
    private static readonly pb::MessageParser<ProgramShapeProto> _parser = new pb::MessageParser<ProgramShapeProto>(() => new ProgramShapeProto());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ProgramShapeProto> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Xla.XlaDataReflection.Descriptor.MessageTypes[4]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ProgramShapeProto() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ProgramShapeProto(ProgramShapeProto other) : this() {
      parameters_ = other.parameters_.Clone();
      result_ = other.result_ != null ? other.result_.Clone() : null;
      parameterNames_ = other.parameterNames_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ProgramShapeProto Clone() {
      return new ProgramShapeProto(this);
    }

    /// <summary>Field number for the "parameters" field.</summary>
    public const int ParametersFieldNumber = 1;
    private static readonly pb::FieldCodec<global::Xla.ShapeProto> _repeated_parameters_codec
        = pb::FieldCodec.ForMessage(10, global::Xla.ShapeProto.Parser);
    private readonly pbc::RepeatedField<global::Xla.ShapeProto> parameters_ = new pbc::RepeatedField<global::Xla.ShapeProto>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Xla.ShapeProto> Parameters {
      get { return parameters_; }
    }

    /// <summary>Field number for the "result" field.</summary>
    public const int ResultFieldNumber = 2;
    private global::Xla.ShapeProto result_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Xla.ShapeProto Result {
      get { return result_; }
      set {
        result_ = value;
      }
    }

    /// <summary>Field number for the "parameter_names" field.</summary>
    public const int ParameterNamesFieldNumber = 3;
    private static readonly pb::FieldCodec<string> _repeated_parameterNames_codec
        = pb::FieldCodec.ForString(26);
    private readonly pbc::RepeatedField<string> parameterNames_ = new pbc::RepeatedField<string>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<string> ParameterNames {
      get { return parameterNames_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ProgramShapeProto);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ProgramShapeProto other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!parameters_.Equals(other.parameters_)) return false;
      if (!object.Equals(Result, other.Result)) return false;
      if(!parameterNames_.Equals(other.parameterNames_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= parameters_.GetHashCode();
      if (result_ != null) hash ^= Result.GetHashCode();
      hash ^= parameterNames_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      parameters_.WriteTo(output, _repeated_parameters_codec);
      if (result_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Result);
      }
      parameterNames_.WriteTo(output, _repeated_parameterNames_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      size += parameters_.CalculateSize(_repeated_parameters_codec);
      if (result_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Result);
      }
      size += parameterNames_.CalculateSize(_repeated_parameterNames_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ProgramShapeProto other) {
      if (other == null) {
        return;
      }
      parameters_.Add(other.parameters_);
      if (other.result_ != null) {
        if (result_ == null) {
          Result = new global::Xla.ShapeProto();
        }
        Result.MergeFrom(other.Result);
      }
      parameterNames_.Add(other.parameterNames_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            parameters_.AddEntriesFrom(input, _repeated_parameters_codec);
            break;
          }
          case 18: {
            if (result_ == null) {
              Result = new global::Xla.ShapeProto();
            }
            input.ReadMessage(Result);
            break;
          }
          case 26: {
            parameterNames_.AddEntriesFrom(input, _repeated_parameterNames_codec);
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// Statistics of a computation.
  /// </summary>
  public sealed partial class ComputationStats : pb::IMessage<ComputationStats> {
    private static readonly pb::MessageParser<ComputationStats> _parser = new pb::MessageParser<ComputationStats>(() => new ComputationStats());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ComputationStats> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Xla.XlaDataReflection.Descriptor.MessageTypes[5]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ComputationStats() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ComputationStats(ComputationStats other) : this() {
      flopCount_ = other.flopCount_;
      transcendentalCount_ = other.transcendentalCount_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ComputationStats Clone() {
      return new ComputationStats(this);
    }

    /// <summary>Field number for the "flop_count" field.</summary>
    public const int FlopCountFieldNumber = 1;
    private double flopCount_;
    /// <summary>
    /// The number of floating point operations in the computation.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double FlopCount {
      get { return flopCount_; }
      set {
        flopCount_ = value;
      }
    }

    /// <summary>Field number for the "transcendental_count" field.</summary>
    public const int TranscendentalCountFieldNumber = 2;
    private double transcendentalCount_;
    /// <summary>
    /// The number of transcendental operations (e.g., exp) in the computation.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double TranscendentalCount {
      get { return transcendentalCount_; }
      set {
        transcendentalCount_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ComputationStats);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ComputationStats other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(FlopCount, other.FlopCount)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(TranscendentalCount, other.TranscendentalCount)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (FlopCount != 0D) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(FlopCount);
      if (TranscendentalCount != 0D) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(TranscendentalCount);
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (FlopCount != 0D) {
        output.WriteRawTag(9);
        output.WriteDouble(FlopCount);
      }
      if (TranscendentalCount != 0D) {
        output.WriteRawTag(17);
        output.WriteDouble(TranscendentalCount);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (FlopCount != 0D) {
        size += 1 + 8;
      }
      if (TranscendentalCount != 0D) {
        size += 1 + 8;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ComputationStats other) {
      if (other == null) {
        return;
      }
      if (other.FlopCount != 0D) {
        FlopCount = other.FlopCount;
      }
      if (other.TranscendentalCount != 0D) {
        TranscendentalCount = other.TranscendentalCount;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 9: {
            FlopCount = input.ReadDouble();
            break;
          }
          case 17: {
            TranscendentalCount = input.ReadDouble();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// Symbolization metadata for HLO Instructions.
  ///
  /// This metadata is used for debugging XLA code generation, as well as
  /// performance profiling of XLA-generated executables.
  /// </summary>
  public sealed partial class OpMetadata : pb::IMessage<OpMetadata> {
    private static readonly pb::MessageParser<OpMetadata> _parser = new pb::MessageParser<OpMetadata>(() => new OpMetadata());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<OpMetadata> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Xla.XlaDataReflection.Descriptor.MessageTypes[6]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public OpMetadata() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public OpMetadata(OpMetadata other) : this() {
      opType_ = other.opType_;
      opName_ = other.opName_;
      sourceFile_ = other.sourceFile_;
      sourceLine_ = other.sourceLine_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public OpMetadata Clone() {
      return new OpMetadata(this);
    }

    /// <summary>Field number for the "op_type" field.</summary>
    public const int OpTypeFieldNumber = 1;
    private string opType_ = "";
    /// <summary>
    /// The framework op name that generated this XLA op.
    ///
    /// Frameworks that build on top of XLA should mirror the names of their ops
    /// back to users by specifying the op_type. In this way, even if the
    /// framework's "ops" are implemented as multiple XLA HLO Ops, they can be
    /// grouped appropriately. (e.g. if a SoftMax layer is emitted into XLA as
    /// multiple ops, then each op should have the op_type be "SoftMax".)
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string OpType {
      get { return opType_; }
      set {
        opType_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "op_name" field.</summary>
    public const int OpNameFieldNumber = 2;
    private string opName_ = "";
    /// <summary>
    /// The user-specified name of the op.
    ///
    /// This name is often unique within a computation. Note: some frameworks
    /// add auto-generated names if the user does not provide one.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string OpName {
      get { return opName_; }
      set {
        opName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "source_file" field.</summary>
    public const int SourceFileFieldNumber = 3;
    private string sourceFile_ = "";
    /// <summary>
    /// Indicate a file and line that this op is associated to in a user's program.
    ///
    /// e.g. it could be the file and line of user code that generated the op.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string SourceFile {
      get { return sourceFile_; }
      set {
        sourceFile_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "source_line" field.</summary>
    public const int SourceLineFieldNumber = 4;
    private int sourceLine_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int SourceLine {
      get { return sourceLine_; }
      set {
        sourceLine_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as OpMetadata);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(OpMetadata other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (OpType != other.OpType) return false;
      if (OpName != other.OpName) return false;
      if (SourceFile != other.SourceFile) return false;
      if (SourceLine != other.SourceLine) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (OpType.Length != 0) hash ^= OpType.GetHashCode();
      if (OpName.Length != 0) hash ^= OpName.GetHashCode();
      if (SourceFile.Length != 0) hash ^= SourceFile.GetHashCode();
      if (SourceLine != 0) hash ^= SourceLine.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (OpType.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(OpType);
      }
      if (OpName.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(OpName);
      }
      if (SourceFile.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(SourceFile);
      }
      if (SourceLine != 0) {
        output.WriteRawTag(32);
        output.WriteInt32(SourceLine);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (OpType.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(OpType);
      }
      if (OpName.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(OpName);
      }
      if (SourceFile.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(SourceFile);
      }
      if (SourceLine != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(SourceLine);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(OpMetadata other) {
      if (other == null) {
        return;
      }
      if (other.OpType.Length != 0) {
        OpType = other.OpType;
      }
      if (other.OpName.Length != 0) {
        OpName = other.OpName;
      }
      if (other.SourceFile.Length != 0) {
        SourceFile = other.SourceFile;
      }
      if (other.SourceLine != 0) {
        SourceLine = other.SourceLine;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            OpType = input.ReadString();
            break;
          }
          case 18: {
            OpName = input.ReadString();
            break;
          }
          case 26: {
            SourceFile = input.ReadString();
            break;
          }
          case 32: {
            SourceLine = input.ReadInt32();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// Profile data from the execution of a computation.
  /// </summary>
  public sealed partial class ExecutionProfile : pb::IMessage<ExecutionProfile> {
    private static readonly pb::MessageParser<ExecutionProfile> _parser = new pb::MessageParser<ExecutionProfile>(() => new ExecutionProfile());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ExecutionProfile> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Xla.XlaDataReflection.Descriptor.MessageTypes[7]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ExecutionProfile() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ExecutionProfile(ExecutionProfile other) : this() {
      compilationCacheHit_ = other.compilationCacheHit_;
      compileTimeMs_ = other.compileTimeMs_;
      computeCycleCount_ = other.computeCycleCount_;
      computeTimeNs_ = other.computeTimeNs_;
      computeAndTransferTimeNs_ = other.computeAndTransferTimeNs_;
      executableSizeInBytes_ = other.executableSizeInBytes_;
      profileCacheHit_ = other.profileCacheHit_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ExecutionProfile Clone() {
      return new ExecutionProfile(this);
    }

    /// <summary>Field number for the "compilation_cache_hit" field.</summary>
    public const int CompilationCacheHitFieldNumber = 1;
    private bool compilationCacheHit_;
    /// <summary>
    /// Whether the executable was read from the compilation cache.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool CompilationCacheHit {
      get { return compilationCacheHit_; }
      set {
        compilationCacheHit_ = value;
      }
    }

    /// <summary>Field number for the "compile_time_ms" field.</summary>
    public const int CompileTimeMsFieldNumber = 2;
    private long compileTimeMs_;
    /// <summary>
    /// The time in milliseconds spent to compile the computation. This only set if
    /// the executable was not read from the compilation cache
    /// (compilation_cache_hit == false).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long CompileTimeMs {
      get { return compileTimeMs_; }
      set {
        compileTimeMs_ = value;
      }
    }

    /// <summary>Field number for the "compute_cycle_count" field.</summary>
    public const int ComputeCycleCountFieldNumber = 3;
    private long computeCycleCount_;
    /// <summary>
    /// The number of cycles spent for the computation. This does not include the
    /// time taken for the data transfers between the host and the device. This is
    /// a target-dependent field and only used for debugging purposes.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long ComputeCycleCount {
      get { return computeCycleCount_; }
      set {
        computeCycleCount_ = value;
      }
    }

    /// <summary>Field number for the "compute_time_ns" field.</summary>
    public const int ComputeTimeNsFieldNumber = 4;
    private long computeTimeNs_;
    /// <summary>
    /// The time in nanoseconds spent for the computation, without data transfer.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long ComputeTimeNs {
      get { return computeTimeNs_; }
      set {
        computeTimeNs_ = value;
      }
    }

    /// <summary>Field number for the "compute_and_transfer_time_ns" field.</summary>
    public const int ComputeAndTransferTimeNsFieldNumber = 5;
    private long computeAndTransferTimeNs_;
    /// <summary>
    /// The time in nanoseconds spent for the entire computation, including the
    /// result data transfer time. Current implementation does not spend any cycles
    /// for the input data transfer since the memory is initialized with the proper
    /// values before the execution.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long ComputeAndTransferTimeNs {
      get { return computeAndTransferTimeNs_; }
      set {
        computeAndTransferTimeNs_ = value;
      }
    }

    /// <summary>Field number for the "executable_size_in_bytes" field.</summary>
    public const int ExecutableSizeInBytesFieldNumber = 6;
    private long executableSizeInBytes_;
    /// <summary>
    /// The size of the binary code in the executable.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long ExecutableSizeInBytes {
      get { return executableSizeInBytes_; }
      set {
        executableSizeInBytes_ = value;
      }
    }

    /// <summary>Field number for the "profile_cache_hit" field.</summary>
    public const int ProfileCacheHitFieldNumber = 7;
    private bool profileCacheHit_;
    /// <summary>
    /// Whether this profile was drawn from a cache of profiles instead of from
    /// execution on the hardware.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool ProfileCacheHit {
      get { return profileCacheHit_; }
      set {
        profileCacheHit_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ExecutionProfile);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ExecutionProfile other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (CompilationCacheHit != other.CompilationCacheHit) return false;
      if (CompileTimeMs != other.CompileTimeMs) return false;
      if (ComputeCycleCount != other.ComputeCycleCount) return false;
      if (ComputeTimeNs != other.ComputeTimeNs) return false;
      if (ComputeAndTransferTimeNs != other.ComputeAndTransferTimeNs) return false;
      if (ExecutableSizeInBytes != other.ExecutableSizeInBytes) return false;
      if (ProfileCacheHit != other.ProfileCacheHit) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (CompilationCacheHit != false) hash ^= CompilationCacheHit.GetHashCode();
      if (CompileTimeMs != 0L) hash ^= CompileTimeMs.GetHashCode();
      if (ComputeCycleCount != 0L) hash ^= ComputeCycleCount.GetHashCode();
      if (ComputeTimeNs != 0L) hash ^= ComputeTimeNs.GetHashCode();
      if (ComputeAndTransferTimeNs != 0L) hash ^= ComputeAndTransferTimeNs.GetHashCode();
      if (ExecutableSizeInBytes != 0L) hash ^= ExecutableSizeInBytes.GetHashCode();
      if (ProfileCacheHit != false) hash ^= ProfileCacheHit.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (CompilationCacheHit != false) {
        output.WriteRawTag(8);
        output.WriteBool(CompilationCacheHit);
      }
      if (CompileTimeMs != 0L) {
        output.WriteRawTag(16);
        output.WriteInt64(CompileTimeMs);
      }
      if (ComputeCycleCount != 0L) {
        output.WriteRawTag(24);
        output.WriteInt64(ComputeCycleCount);
      }
      if (ComputeTimeNs != 0L) {
        output.WriteRawTag(32);
        output.WriteInt64(ComputeTimeNs);
      }
      if (ComputeAndTransferTimeNs != 0L) {
        output.WriteRawTag(40);
        output.WriteInt64(ComputeAndTransferTimeNs);
      }
      if (ExecutableSizeInBytes != 0L) {
        output.WriteRawTag(48);
        output.WriteInt64(ExecutableSizeInBytes);
      }
      if (ProfileCacheHit != false) {
        output.WriteRawTag(56);
        output.WriteBool(ProfileCacheHit);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (CompilationCacheHit != false) {
        size += 1 + 1;
      }
      if (CompileTimeMs != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(CompileTimeMs);
      }
      if (ComputeCycleCount != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(ComputeCycleCount);
      }
      if (ComputeTimeNs != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(ComputeTimeNs);
      }
      if (ComputeAndTransferTimeNs != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(ComputeAndTransferTimeNs);
      }
      if (ExecutableSizeInBytes != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(ExecutableSizeInBytes);
      }
      if (ProfileCacheHit != false) {
        size += 1 + 1;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ExecutionProfile other) {
      if (other == null) {
        return;
      }
      if (other.CompilationCacheHit != false) {
        CompilationCacheHit = other.CompilationCacheHit;
      }
      if (other.CompileTimeMs != 0L) {
        CompileTimeMs = other.CompileTimeMs;
      }
      if (other.ComputeCycleCount != 0L) {
        ComputeCycleCount = other.ComputeCycleCount;
      }
      if (other.ComputeTimeNs != 0L) {
        ComputeTimeNs = other.ComputeTimeNs;
      }
      if (other.ComputeAndTransferTimeNs != 0L) {
        ComputeAndTransferTimeNs = other.ComputeAndTransferTimeNs;
      }
      if (other.ExecutableSizeInBytes != 0L) {
        ExecutableSizeInBytes = other.ExecutableSizeInBytes;
      }
      if (other.ProfileCacheHit != false) {
        ProfileCacheHit = other.ProfileCacheHit;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            CompilationCacheHit = input.ReadBool();
            break;
          }
          case 16: {
            CompileTimeMs = input.ReadInt64();
            break;
          }
          case 24: {
            ComputeCycleCount = input.ReadInt64();
            break;
          }
          case 32: {
            ComputeTimeNs = input.ReadInt64();
            break;
          }
          case 40: {
            ComputeAndTransferTimeNs = input.ReadInt64();
            break;
          }
          case 48: {
            ExecutableSizeInBytes = input.ReadInt64();
            break;
          }
          case 56: {
            ProfileCacheHit = input.ReadBool();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// Handle given to a user that represents an execution that the user launched
  /// asynchronously on the device.
  /// </summary>
  public sealed partial class ExecutionHandle : pb::IMessage<ExecutionHandle> {
    private static readonly pb::MessageParser<ExecutionHandle> _parser = new pb::MessageParser<ExecutionHandle>(() => new ExecutionHandle());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ExecutionHandle> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Xla.XlaDataReflection.Descriptor.MessageTypes[8]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ExecutionHandle() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ExecutionHandle(ExecutionHandle other) : this() {
      handle_ = other.handle_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ExecutionHandle Clone() {
      return new ExecutionHandle(this);
    }

    /// <summary>Field number for the "handle" field.</summary>
    public const int HandleFieldNumber = 1;
    private long handle_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long Handle {
      get { return handle_; }
      set {
        handle_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ExecutionHandle);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ExecutionHandle other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Handle != other.Handle) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Handle != 0L) hash ^= Handle.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Handle != 0L) {
        output.WriteRawTag(8);
        output.WriteInt64(Handle);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Handle != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(Handle);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ExecutionHandle other) {
      if (other == null) {
        return;
      }
      if (other.Handle != 0L) {
        Handle = other.Handle;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            Handle = input.ReadInt64();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// Handle given to a user that represents a globally accessible allocation.
  /// Contrast this against a ComputationDataHandle, which is not globally
  /// accessible, since it only exists within a specific computation.
  /// </summary>
  public sealed partial class GlobalDataHandle : pb::IMessage<GlobalDataHandle> {
    private static readonly pb::MessageParser<GlobalDataHandle> _parser = new pb::MessageParser<GlobalDataHandle>(() => new GlobalDataHandle());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<GlobalDataHandle> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Xla.XlaDataReflection.Descriptor.MessageTypes[9]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public GlobalDataHandle() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public GlobalDataHandle(GlobalDataHandle other) : this() {
      handle_ = other.handle_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public GlobalDataHandle Clone() {
      return new GlobalDataHandle(this);
    }

    /// <summary>Field number for the "handle" field.</summary>
    public const int HandleFieldNumber = 1;
    private long handle_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long Handle {
      get { return handle_; }
      set {
        handle_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as GlobalDataHandle);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(GlobalDataHandle other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Handle != other.Handle) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Handle != 0L) hash ^= Handle.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Handle != 0L) {
        output.WriteRawTag(8);
        output.WriteInt64(Handle);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Handle != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(Handle);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(GlobalDataHandle other) {
      if (other == null) {
        return;
      }
      if (other.Handle != 0L) {
        Handle = other.Handle;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            Handle = input.ReadInt64();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// Handle given to a user that represents a replicated virtual device. Each
  /// replicated device represents N physical devices for execution where N is the
  /// number of replicas.
  /// </summary>
  public sealed partial class DeviceHandle : pb::IMessage<DeviceHandle> {
    private static readonly pb::MessageParser<DeviceHandle> _parser = new pb::MessageParser<DeviceHandle>(() => new DeviceHandle());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<DeviceHandle> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Xla.XlaDataReflection.Descriptor.MessageTypes[10]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public DeviceHandle() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public DeviceHandle(DeviceHandle other) : this() {
      handle_ = other.handle_;
      deviceCount_ = other.deviceCount_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public DeviceHandle Clone() {
      return new DeviceHandle(this);
    }

    /// <summary>Field number for the "handle" field.</summary>
    public const int HandleFieldNumber = 1;
    private long handle_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long Handle {
      get { return handle_; }
      set {
        handle_ = value;
      }
    }

    /// <summary>Field number for the "device_count" field.</summary>
    public const int DeviceCountFieldNumber = 2;
    private long deviceCount_;
    /// <summary>
    /// The number of model-parallel virtual devices that communicate via XLA
    /// Send/Recv instructions.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long DeviceCount {
      get { return deviceCount_; }
      set {
        deviceCount_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as DeviceHandle);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(DeviceHandle other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Handle != other.Handle) return false;
      if (DeviceCount != other.DeviceCount) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Handle != 0L) hash ^= Handle.GetHashCode();
      if (DeviceCount != 0L) hash ^= DeviceCount.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Handle != 0L) {
        output.WriteRawTag(8);
        output.WriteInt64(Handle);
      }
      if (DeviceCount != 0L) {
        output.WriteRawTag(16);
        output.WriteInt64(DeviceCount);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Handle != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(Handle);
      }
      if (DeviceCount != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(DeviceCount);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(DeviceHandle other) {
      if (other == null) {
        return;
      }
      if (other.Handle != 0L) {
        Handle = other.Handle;
      }
      if (other.DeviceCount != 0L) {
        DeviceCount = other.DeviceCount;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            Handle = input.ReadInt64();
            break;
          }
          case 16: {
            DeviceCount = input.ReadInt64();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// Handle given to a user to represent a channel between two computations
  /// via a Send and Recv instruction pair. Channels are unbuffered, so Send
  /// Send instructions will be blocked until the data is transferred.
  /// </summary>
  public sealed partial class ChannelHandle : pb::IMessage<ChannelHandle> {
    private static readonly pb::MessageParser<ChannelHandle> _parser = new pb::MessageParser<ChannelHandle>(() => new ChannelHandle());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ChannelHandle> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Xla.XlaDataReflection.Descriptor.MessageTypes[11]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ChannelHandle() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ChannelHandle(ChannelHandle other) : this() {
      handle_ = other.handle_;
      type_ = other.type_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ChannelHandle Clone() {
      return new ChannelHandle(this);
    }

    /// <summary>Field number for the "handle" field.</summary>
    public const int HandleFieldNumber = 1;
    private long handle_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long Handle {
      get { return handle_; }
      set {
        handle_ = value;
      }
    }

    /// <summary>Field number for the "type" field.</summary>
    public const int TypeFieldNumber = 2;
    private global::Xla.ChannelHandle.Types.ChannelType type_ = 0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Xla.ChannelHandle.Types.ChannelType Type {
      get { return type_; }
      set {
        type_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ChannelHandle);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ChannelHandle other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Handle != other.Handle) return false;
      if (Type != other.Type) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Handle != 0L) hash ^= Handle.GetHashCode();
      if (Type != 0) hash ^= Type.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Handle != 0L) {
        output.WriteRawTag(8);
        output.WriteInt64(Handle);
      }
      if (Type != 0) {
        output.WriteRawTag(16);
        output.WriteEnum((int) Type);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Handle != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(Handle);
      }
      if (Type != 0) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Type);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ChannelHandle other) {
      if (other == null) {
        return;
      }
      if (other.Handle != 0L) {
        Handle = other.Handle;
      }
      if (other.Type != 0) {
        Type = other.Type;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            Handle = input.ReadInt64();
            break;
          }
          case 16: {
            Type = (global::Xla.ChannelHandle.Types.ChannelType) input.ReadEnum();
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the ChannelHandle message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      public enum ChannelType {
        /// <summary>
        /// Invalid primitive type to serve as default.
        /// </summary>
        [pbr::OriginalName("CHANNEL_TYPE_INVALID")] Invalid = 0,
        /// <summary>
        /// A channel for sending data between devices.
        /// </summary>
        [pbr::OriginalName("DEVICE_TO_DEVICE")] DeviceToDevice = 1,
        /// <summary>
        /// A channel for sending data from the device to the host. Can only be used
        /// with a Send operation.
        /// </summary>
        [pbr::OriginalName("DEVICE_TO_HOST")] DeviceToHost = 2,
        /// <summary>
        /// A channel for sending data from the host to the device. Can only be used
        /// with a Recv operation.
        /// </summary>
        [pbr::OriginalName("HOST_TO_DEVICE")] HostToDevice = 3,
      }

    }
    #endregion

  }

  /// <summary>
  /// DeviceAssignmentProto is a serialized form of DeviceAssignment class, which
  /// represents the device ids assigned to a set of replicated computations.
  /// See xla::DeviceAssignment class comment for more details.
  /// </summary>
  public sealed partial class DeviceAssignmentProto : pb::IMessage<DeviceAssignmentProto> {
    private static readonly pb::MessageParser<DeviceAssignmentProto> _parser = new pb::MessageParser<DeviceAssignmentProto>(() => new DeviceAssignmentProto());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<DeviceAssignmentProto> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Xla.XlaDataReflection.Descriptor.MessageTypes[12]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public DeviceAssignmentProto() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public DeviceAssignmentProto(DeviceAssignmentProto other) : this() {
      replicaCount_ = other.replicaCount_;
      computationCount_ = other.computationCount_;
      computationDevices_ = other.computationDevices_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public DeviceAssignmentProto Clone() {
      return new DeviceAssignmentProto(this);
    }

    /// <summary>Field number for the "replica_count" field.</summary>
    public const int ReplicaCountFieldNumber = 1;
    private int replicaCount_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int ReplicaCount {
      get { return replicaCount_; }
      set {
        replicaCount_ = value;
      }
    }

    /// <summary>Field number for the "computation_count" field.</summary>
    public const int ComputationCountFieldNumber = 2;
    private int computationCount_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int ComputationCount {
      get { return computationCount_; }
      set {
        computationCount_ = value;
      }
    }

    /// <summary>Field number for the "computation_devices" field.</summary>
    public const int ComputationDevicesFieldNumber = 3;
    private static readonly pb::FieldCodec<global::Xla.DeviceAssignmentProto.Types.ComputationDevice> _repeated_computationDevices_codec
        = pb::FieldCodec.ForMessage(26, global::Xla.DeviceAssignmentProto.Types.ComputationDevice.Parser);
    private readonly pbc::RepeatedField<global::Xla.DeviceAssignmentProto.Types.ComputationDevice> computationDevices_ = new pbc::RepeatedField<global::Xla.DeviceAssignmentProto.Types.ComputationDevice>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Xla.DeviceAssignmentProto.Types.ComputationDevice> ComputationDevices {
      get { return computationDevices_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as DeviceAssignmentProto);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(DeviceAssignmentProto other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (ReplicaCount != other.ReplicaCount) return false;
      if (ComputationCount != other.ComputationCount) return false;
      if(!computationDevices_.Equals(other.computationDevices_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (ReplicaCount != 0) hash ^= ReplicaCount.GetHashCode();
      if (ComputationCount != 0) hash ^= ComputationCount.GetHashCode();
      hash ^= computationDevices_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (ReplicaCount != 0) {
        output.WriteRawTag(8);
        output.WriteInt32(ReplicaCount);
      }
      if (ComputationCount != 0) {
        output.WriteRawTag(16);
        output.WriteInt32(ComputationCount);
      }
      computationDevices_.WriteTo(output, _repeated_computationDevices_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (ReplicaCount != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(ReplicaCount);
      }
      if (ComputationCount != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(ComputationCount);
      }
      size += computationDevices_.CalculateSize(_repeated_computationDevices_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(DeviceAssignmentProto other) {
      if (other == null) {
        return;
      }
      if (other.ReplicaCount != 0) {
        ReplicaCount = other.ReplicaCount;
      }
      if (other.ComputationCount != 0) {
        ComputationCount = other.ComputationCount;
      }
      computationDevices_.Add(other.computationDevices_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            ReplicaCount = input.ReadInt32();
            break;
          }
          case 16: {
            ComputationCount = input.ReadInt32();
            break;
          }
          case 26: {
            computationDevices_.AddEntriesFrom(input, _repeated_computationDevices_codec);
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the DeviceAssignmentProto message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      /// <summary>
      /// Each logical computation runs on replica_count physical devices.
      /// ComputationDevice represents the device ids assinged to the replicas.
      /// </summary>
      public sealed partial class ComputationDevice : pb::IMessage<ComputationDevice> {
        private static readonly pb::MessageParser<ComputationDevice> _parser = new pb::MessageParser<ComputationDevice>(() => new ComputationDevice());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<ComputationDevice> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Xla.DeviceAssignmentProto.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public ComputationDevice() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public ComputationDevice(ComputationDevice other) : this() {
          replicaDeviceIds_ = other.replicaDeviceIds_.Clone();
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public ComputationDevice Clone() {
          return new ComputationDevice(this);
        }

        /// <summary>Field number for the "replica_device_ids" field.</summary>
        public const int ReplicaDeviceIdsFieldNumber = 1;
        private static readonly pb::FieldCodec<int> _repeated_replicaDeviceIds_codec
            = pb::FieldCodec.ForInt32(10);
        private readonly pbc::RepeatedField<int> replicaDeviceIds_ = new pbc::RepeatedField<int>();
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<int> ReplicaDeviceIds {
          get { return replicaDeviceIds_; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as ComputationDevice);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(ComputationDevice other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if(!replicaDeviceIds_.Equals(other.replicaDeviceIds_)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          hash ^= replicaDeviceIds_.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          replicaDeviceIds_.WriteTo(output, _repeated_replicaDeviceIds_codec);
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          size += replicaDeviceIds_.CalculateSize(_repeated_replicaDeviceIds_codec);
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(ComputationDevice other) {
          if (other == null) {
            return;
          }
          replicaDeviceIds_.Add(other.replicaDeviceIds_);
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10:
              case 8: {
                replicaDeviceIds_.AddEntriesFrom(input, _repeated_replicaDeviceIds_codec);
                break;
              }
            }
          }
        }

      }

    }
    #endregion

  }

  /// <summary>
  /// Literals are used when the server and client need to exchange materialized
  /// data / results. Literals are also used to describe constants used in
  /// computations.
  ///
  /// Transfers to/from the client are encoded in literal form, and the structure
  /// of the repeated fields is implied by the shape.
  /// </summary>
  public sealed partial class LiteralProto : pb::IMessage<LiteralProto> {
    private static readonly pb::MessageParser<LiteralProto> _parser = new pb::MessageParser<LiteralProto>(() => new LiteralProto());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<LiteralProto> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Xla.XlaDataReflection.Descriptor.MessageTypes[13]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public LiteralProto() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public LiteralProto(LiteralProto other) : this() {
      shape_ = other.shape_ != null ? other.shape_.Clone() : null;
      preds_ = other.preds_.Clone();
      s8S_ = other.s8S_;
      u8S_ = other.u8S_;
      s32S_ = other.s32S_.Clone();
      s64S_ = other.s64S_.Clone();
      u32S_ = other.u32S_.Clone();
      u64S_ = other.u64S_.Clone();
      f32S_ = other.f32S_.Clone();
      f64S_ = other.f64S_.Clone();
      c64S_ = other.c64S_.Clone();
      c128S_ = other.c128S_.Clone();
      tupleLiterals_ = other.tupleLiterals_.Clone();
      f16S_ = other.f16S_;
      bf16S_ = other.bf16S_;
      u16S_ = other.u16S_;
      s16S_ = other.s16S_;
      sparseIndices_ = other.sparseIndices_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public LiteralProto Clone() {
      return new LiteralProto(this);
    }

    /// <summary>Field number for the "shape" field.</summary>
    public const int ShapeFieldNumber = 1;
    private global::Xla.ShapeProto shape_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Xla.ShapeProto Shape {
      get { return shape_; }
      set {
        shape_ = value;
      }
    }

    /// <summary>Field number for the "preds" field.</summary>
    public const int PredsFieldNumber = 2;
    private static readonly pb::FieldCodec<bool> _repeated_preds_codec
        = pb::FieldCodec.ForBool(18);
    private readonly pbc::RepeatedField<bool> preds_ = new pbc::RepeatedField<bool>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<bool> Preds {
      get { return preds_; }
    }

    /// <summary>Field number for the "s8s" field.</summary>
    public const int S8SFieldNumber = 15;
    private pb::ByteString s8S_ = pb::ByteString.Empty;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pb::ByteString S8S {
      get { return s8S_; }
      set {
        s8S_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "u8s" field.</summary>
    public const int U8SFieldNumber = 3;
    private pb::ByteString u8S_ = pb::ByteString.Empty;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pb::ByteString U8S {
      get { return u8S_; }
      set {
        u8S_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "s32s" field.</summary>
    public const int S32SFieldNumber = 4;
    private static readonly pb::FieldCodec<int> _repeated_s32S_codec
        = pb::FieldCodec.ForInt32(34);
    private readonly pbc::RepeatedField<int> s32S_ = new pbc::RepeatedField<int>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<int> S32S {
      get { return s32S_; }
    }

    /// <summary>Field number for the "s64s" field.</summary>
    public const int S64SFieldNumber = 5;
    private static readonly pb::FieldCodec<long> _repeated_s64S_codec
        = pb::FieldCodec.ForInt64(42);
    private readonly pbc::RepeatedField<long> s64S_ = new pbc::RepeatedField<long>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<long> S64S {
      get { return s64S_; }
    }

    /// <summary>Field number for the "u32s" field.</summary>
    public const int U32SFieldNumber = 6;
    private static readonly pb::FieldCodec<uint> _repeated_u32S_codec
        = pb::FieldCodec.ForUInt32(50);
    private readonly pbc::RepeatedField<uint> u32S_ = new pbc::RepeatedField<uint>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<uint> U32S {
      get { return u32S_; }
    }

    /// <summary>Field number for the "u64s" field.</summary>
    public const int U64SFieldNumber = 7;
    private static readonly pb::FieldCodec<ulong> _repeated_u64S_codec
        = pb::FieldCodec.ForUInt64(58);
    private readonly pbc::RepeatedField<ulong> u64S_ = new pbc::RepeatedField<ulong>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<ulong> U64S {
      get { return u64S_; }
    }

    /// <summary>Field number for the "f32s" field.</summary>
    public const int F32SFieldNumber = 8;
    private static readonly pb::FieldCodec<float> _repeated_f32S_codec
        = pb::FieldCodec.ForFloat(66);
    private readonly pbc::RepeatedField<float> f32S_ = new pbc::RepeatedField<float>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<float> F32S {
      get { return f32S_; }
    }

    /// <summary>Field number for the "f64s" field.</summary>
    public const int F64SFieldNumber = 9;
    private static readonly pb::FieldCodec<double> _repeated_f64S_codec
        = pb::FieldCodec.ForDouble(74);
    private readonly pbc::RepeatedField<double> f64S_ = new pbc::RepeatedField<double>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<double> F64S {
      get { return f64S_; }
    }

    /// <summary>Field number for the "c64s" field.</summary>
    public const int C64SFieldNumber = 12;
    private static readonly pb::FieldCodec<float> _repeated_c64S_codec
        = pb::FieldCodec.ForFloat(98);
    private readonly pbc::RepeatedField<float> c64S_ = new pbc::RepeatedField<float>();
    /// <summary>
    /// Stored as interleaved real, imag floats.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<float> C64S {
      get { return c64S_; }
    }

    /// <summary>Field number for the "c128s" field.</summary>
    public const int C128SFieldNumber = 18;
    private static readonly pb::FieldCodec<double> _repeated_c128S_codec
        = pb::FieldCodec.ForDouble(146);
    private readonly pbc::RepeatedField<double> c128S_ = new pbc::RepeatedField<double>();
    /// <summary>
    /// Stored as interleaved real, imag doubles.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<double> C128S {
      get { return c128S_; }
    }

    /// <summary>Field number for the "tuple_literals" field.</summary>
    public const int TupleLiteralsFieldNumber = 10;
    private static readonly pb::FieldCodec<global::Xla.LiteralProto> _repeated_tupleLiterals_codec
        = pb::FieldCodec.ForMessage(82, global::Xla.LiteralProto.Parser);
    private readonly pbc::RepeatedField<global::Xla.LiteralProto> tupleLiterals_ = new pbc::RepeatedField<global::Xla.LiteralProto>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Xla.LiteralProto> TupleLiterals {
      get { return tupleLiterals_; }
    }

    /// <summary>Field number for the "f16s" field.</summary>
    public const int F16SFieldNumber = 11;
    private pb::ByteString f16S_ = pb::ByteString.Empty;
    /// <summary>
    /// The F16s, BF16s, U16s and S16s are encoded in little endian byte order
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pb::ByteString F16S {
      get { return f16S_; }
      set {
        f16S_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "bf16s" field.</summary>
    public const int Bf16SFieldNumber = 13;
    private pb::ByteString bf16S_ = pb::ByteString.Empty;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pb::ByteString Bf16S {
      get { return bf16S_; }
      set {
        bf16S_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "u16s" field.</summary>
    public const int U16SFieldNumber = 16;
    private pb::ByteString u16S_ = pb::ByteString.Empty;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pb::ByteString U16S {
      get { return u16S_; }
      set {
        u16S_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "s16s" field.</summary>
    public const int S16SFieldNumber = 17;
    private pb::ByteString s16S_ = pb::ByteString.Empty;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pb::ByteString S16S {
      get { return s16S_; }
      set {
        s16S_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "sparse_indices" field.</summary>
    public const int SparseIndicesFieldNumber = 14;
    private static readonly pb::FieldCodec<long> _repeated_sparseIndices_codec
        = pb::FieldCodec.ForInt64(114);
    private readonly pbc::RepeatedField<long> sparseIndices_ = new pbc::RepeatedField<long>();
    /// <summary>
    /// Next = 19
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<long> SparseIndices {
      get { return sparseIndices_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as LiteralProto);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(LiteralProto other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Shape, other.Shape)) return false;
      if(!preds_.Equals(other.preds_)) return false;
      if (S8S != other.S8S) return false;
      if (U8S != other.U8S) return false;
      if(!s32S_.Equals(other.s32S_)) return false;
      if(!s64S_.Equals(other.s64S_)) return false;
      if(!u32S_.Equals(other.u32S_)) return false;
      if(!u64S_.Equals(other.u64S_)) return false;
      if(!f32S_.Equals(other.f32S_)) return false;
      if(!f64S_.Equals(other.f64S_)) return false;
      if(!c64S_.Equals(other.c64S_)) return false;
      if(!c128S_.Equals(other.c128S_)) return false;
      if(!tupleLiterals_.Equals(other.tupleLiterals_)) return false;
      if (F16S != other.F16S) return false;
      if (Bf16S != other.Bf16S) return false;
      if (U16S != other.U16S) return false;
      if (S16S != other.S16S) return false;
      if(!sparseIndices_.Equals(other.sparseIndices_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (shape_ != null) hash ^= Shape.GetHashCode();
      hash ^= preds_.GetHashCode();
      if (S8S.Length != 0) hash ^= S8S.GetHashCode();
      if (U8S.Length != 0) hash ^= U8S.GetHashCode();
      hash ^= s32S_.GetHashCode();
      hash ^= s64S_.GetHashCode();
      hash ^= u32S_.GetHashCode();
      hash ^= u64S_.GetHashCode();
      hash ^= f32S_.GetHashCode();
      hash ^= f64S_.GetHashCode();
      hash ^= c64S_.GetHashCode();
      hash ^= c128S_.GetHashCode();
      hash ^= tupleLiterals_.GetHashCode();
      if (F16S.Length != 0) hash ^= F16S.GetHashCode();
      if (Bf16S.Length != 0) hash ^= Bf16S.GetHashCode();
      if (U16S.Length != 0) hash ^= U16S.GetHashCode();
      if (S16S.Length != 0) hash ^= S16S.GetHashCode();
      hash ^= sparseIndices_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (shape_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Shape);
      }
      preds_.WriteTo(output, _repeated_preds_codec);
      if (U8S.Length != 0) {
        output.WriteRawTag(26);
        output.WriteBytes(U8S);
      }
      s32S_.WriteTo(output, _repeated_s32S_codec);
      s64S_.WriteTo(output, _repeated_s64S_codec);
      u32S_.WriteTo(output, _repeated_u32S_codec);
      u64S_.WriteTo(output, _repeated_u64S_codec);
      f32S_.WriteTo(output, _repeated_f32S_codec);
      f64S_.WriteTo(output, _repeated_f64S_codec);
      tupleLiterals_.WriteTo(output, _repeated_tupleLiterals_codec);
      if (F16S.Length != 0) {
        output.WriteRawTag(90);
        output.WriteBytes(F16S);
      }
      c64S_.WriteTo(output, _repeated_c64S_codec);
      if (Bf16S.Length != 0) {
        output.WriteRawTag(106);
        output.WriteBytes(Bf16S);
      }
      sparseIndices_.WriteTo(output, _repeated_sparseIndices_codec);
      if (S8S.Length != 0) {
        output.WriteRawTag(122);
        output.WriteBytes(S8S);
      }
      if (U16S.Length != 0) {
        output.WriteRawTag(130, 1);
        output.WriteBytes(U16S);
      }
      if (S16S.Length != 0) {
        output.WriteRawTag(138, 1);
        output.WriteBytes(S16S);
      }
      c128S_.WriteTo(output, _repeated_c128S_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (shape_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Shape);
      }
      size += preds_.CalculateSize(_repeated_preds_codec);
      if (S8S.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(S8S);
      }
      if (U8S.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(U8S);
      }
      size += s32S_.CalculateSize(_repeated_s32S_codec);
      size += s64S_.CalculateSize(_repeated_s64S_codec);
      size += u32S_.CalculateSize(_repeated_u32S_codec);
      size += u64S_.CalculateSize(_repeated_u64S_codec);
      size += f32S_.CalculateSize(_repeated_f32S_codec);
      size += f64S_.CalculateSize(_repeated_f64S_codec);
      size += c64S_.CalculateSize(_repeated_c64S_codec);
      size += c128S_.CalculateSize(_repeated_c128S_codec);
      size += tupleLiterals_.CalculateSize(_repeated_tupleLiterals_codec);
      if (F16S.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(F16S);
      }
      if (Bf16S.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(Bf16S);
      }
      if (U16S.Length != 0) {
        size += 2 + pb::CodedOutputStream.ComputeBytesSize(U16S);
      }
      if (S16S.Length != 0) {
        size += 2 + pb::CodedOutputStream.ComputeBytesSize(S16S);
      }
      size += sparseIndices_.CalculateSize(_repeated_sparseIndices_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(LiteralProto other) {
      if (other == null) {
        return;
      }
      if (other.shape_ != null) {
        if (shape_ == null) {
          Shape = new global::Xla.ShapeProto();
        }
        Shape.MergeFrom(other.Shape);
      }
      preds_.Add(other.preds_);
      if (other.S8S.Length != 0) {
        S8S = other.S8S;
      }
      if (other.U8S.Length != 0) {
        U8S = other.U8S;
      }
      s32S_.Add(other.s32S_);
      s64S_.Add(other.s64S_);
      u32S_.Add(other.u32S_);
      u64S_.Add(other.u64S_);
      f32S_.Add(other.f32S_);
      f64S_.Add(other.f64S_);
      c64S_.Add(other.c64S_);
      c128S_.Add(other.c128S_);
      tupleLiterals_.Add(other.tupleLiterals_);
      if (other.F16S.Length != 0) {
        F16S = other.F16S;
      }
      if (other.Bf16S.Length != 0) {
        Bf16S = other.Bf16S;
      }
      if (other.U16S.Length != 0) {
        U16S = other.U16S;
      }
      if (other.S16S.Length != 0) {
        S16S = other.S16S;
      }
      sparseIndices_.Add(other.sparseIndices_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (shape_ == null) {
              Shape = new global::Xla.ShapeProto();
            }
            input.ReadMessage(Shape);
            break;
          }
          case 18:
          case 16: {
            preds_.AddEntriesFrom(input, _repeated_preds_codec);
            break;
          }
          case 26: {
            U8S = input.ReadBytes();
            break;
          }
          case 34:
          case 32: {
            s32S_.AddEntriesFrom(input, _repeated_s32S_codec);
            break;
          }
          case 42:
          case 40: {
            s64S_.AddEntriesFrom(input, _repeated_s64S_codec);
            break;
          }
          case 50:
          case 48: {
            u32S_.AddEntriesFrom(input, _repeated_u32S_codec);
            break;
          }
          case 58:
          case 56: {
            u64S_.AddEntriesFrom(input, _repeated_u64S_codec);
            break;
          }
          case 66:
          case 69: {
            f32S_.AddEntriesFrom(input, _repeated_f32S_codec);
            break;
          }
          case 74:
          case 73: {
            f64S_.AddEntriesFrom(input, _repeated_f64S_codec);
            break;
          }
          case 82: {
            tupleLiterals_.AddEntriesFrom(input, _repeated_tupleLiterals_codec);
            break;
          }
          case 90: {
            F16S = input.ReadBytes();
            break;
          }
          case 98:
          case 101: {
            c64S_.AddEntriesFrom(input, _repeated_c64S_codec);
            break;
          }
          case 106: {
            Bf16S = input.ReadBytes();
            break;
          }
          case 114:
          case 112: {
            sparseIndices_.AddEntriesFrom(input, _repeated_sparseIndices_codec);
            break;
          }
          case 122: {
            S8S = input.ReadBytes();
            break;
          }
          case 130: {
            U16S = input.ReadBytes();
            break;
          }
          case 138: {
            S16S = input.ReadBytes();
            break;
          }
          case 146:
          case 145: {
            c128S_.AddEntriesFrom(input, _repeated_c128S_codec);
            break;
          }
        }
      }
    }

  }

  public sealed partial class WindowDimension : pb::IMessage<WindowDimension> {
    private static readonly pb::MessageParser<WindowDimension> _parser = new pb::MessageParser<WindowDimension>(() => new WindowDimension());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<WindowDimension> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Xla.XlaDataReflection.Descriptor.MessageTypes[14]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public WindowDimension() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public WindowDimension(WindowDimension other) : this() {
      size_ = other.size_;
      stride_ = other.stride_;
      paddingLow_ = other.paddingLow_;
      paddingHigh_ = other.paddingHigh_;
      windowDilation_ = other.windowDilation_;
      baseDilation_ = other.baseDilation_;
      windowReversal_ = other.windowReversal_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public WindowDimension Clone() {
      return new WindowDimension(this);
    }

    /// <summary>Field number for the "size" field.</summary>
    public const int SizeFieldNumber = 1;
    private long size_;
    /// <summary>
    /// The size of the window in this dimension. For a rectangle, this would be
    /// the width or height.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long Size {
      get { return size_; }
      set {
        size_ = value;
      }
    }

    /// <summary>Field number for the "stride" field.</summary>
    public const int StrideFieldNumber = 2;
    private long stride_;
    /// <summary>
    /// The stride at which the window moves across the base area in this
    /// dimension. In other words, this is the spacing between different
    /// positions of the window in this dimension.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long Stride {
      get { return stride_; }
      set {
        stride_ = value;
      }
    }

    /// <summary>Field number for the "padding_low" field.</summary>
    public const int PaddingLowFieldNumber = 3;
    private long paddingLow_;
    /// <summary>
    /// If positive, means the amount of padding to add to the base area at the low
    /// end of this dimension; if negative, its negative means the number of
    /// elements removed from the low end of this dimension. For example, in the
    /// horizontal dimension of a rectangle, this would be the number of padding
    /// values to pad on the left, given that indices increase when going right.
    /// The actual padding value depends upon the context. Convolution pads with
    /// zeros. ReduceWindow and SelectAndScatter pads with the reduce function's
    /// init value.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long PaddingLow {
      get { return paddingLow_; }
      set {
        paddingLow_ = value;
      }
    }

    /// <summary>Field number for the "padding_high" field.</summary>
    public const int PaddingHighFieldNumber = 4;
    private long paddingHigh_;
    /// <summary>
    /// As padding_low, but on the high end of this dimension. For example, in the
    /// horizontal dimension of a rectangle, this would be the number of values to
    /// pad on the right, given that indices increase when going right.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long PaddingHigh {
      get { return paddingHigh_; }
      set {
        paddingHigh_ = value;
      }
    }

    /// <summary>Field number for the "window_dilation" field.</summary>
    public const int WindowDilationFieldNumber = 5;
    private long windowDilation_;
    /// <summary>
    /// Dilation factor of the sliding window in this dimension. A dilation factor
    /// of 1 means no dilation. window_dilation - 1 no-op entries ("holes") are
    /// implicitly placed between each kernel element. This value may not be less
    /// than 1. See documentation for convolution.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long WindowDilation {
      get { return windowDilation_; }
      set {
        windowDilation_ = value;
      }
    }

    /// <summary>Field number for the "base_dilation" field.</summary>
    public const int BaseDilationFieldNumber = 6;
    private long baseDilation_;
    /// <summary>
    /// Dilation factor of the base area in this dimension. A dilation factor of 1
    /// means no dilation. base_dilation - 1 no-op entries ("holes") are implicitly
    /// placed between each base area element. This value may not be less than 1.
    /// See documentation for convolution.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long BaseDilation {
      get { return baseDilation_; }
      set {
        baseDilation_ = value;
      }
    }

    /// <summary>Field number for the "window_reversal" field.</summary>
    public const int WindowReversalFieldNumber = 7;
    private bool windowReversal_;
    /// <summary>
    /// Window reversal means that this dimension was logically reversed before the
    /// operation.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool WindowReversal {
      get { return windowReversal_; }
      set {
        windowReversal_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as WindowDimension);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(WindowDimension other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Size != other.Size) return false;
      if (Stride != other.Stride) return false;
      if (PaddingLow != other.PaddingLow) return false;
      if (PaddingHigh != other.PaddingHigh) return false;
      if (WindowDilation != other.WindowDilation) return false;
      if (BaseDilation != other.BaseDilation) return false;
      if (WindowReversal != other.WindowReversal) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Size != 0L) hash ^= Size.GetHashCode();
      if (Stride != 0L) hash ^= Stride.GetHashCode();
      if (PaddingLow != 0L) hash ^= PaddingLow.GetHashCode();
      if (PaddingHigh != 0L) hash ^= PaddingHigh.GetHashCode();
      if (WindowDilation != 0L) hash ^= WindowDilation.GetHashCode();
      if (BaseDilation != 0L) hash ^= BaseDilation.GetHashCode();
      if (WindowReversal != false) hash ^= WindowReversal.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Size != 0L) {
        output.WriteRawTag(8);
        output.WriteInt64(Size);
      }
      if (Stride != 0L) {
        output.WriteRawTag(16);
        output.WriteInt64(Stride);
      }
      if (PaddingLow != 0L) {
        output.WriteRawTag(24);
        output.WriteInt64(PaddingLow);
      }
      if (PaddingHigh != 0L) {
        output.WriteRawTag(32);
        output.WriteInt64(PaddingHigh);
      }
      if (WindowDilation != 0L) {
        output.WriteRawTag(40);
        output.WriteInt64(WindowDilation);
      }
      if (BaseDilation != 0L) {
        output.WriteRawTag(48);
        output.WriteInt64(BaseDilation);
      }
      if (WindowReversal != false) {
        output.WriteRawTag(56);
        output.WriteBool(WindowReversal);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Size != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(Size);
      }
      if (Stride != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(Stride);
      }
      if (PaddingLow != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(PaddingLow);
      }
      if (PaddingHigh != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(PaddingHigh);
      }
      if (WindowDilation != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(WindowDilation);
      }
      if (BaseDilation != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(BaseDilation);
      }
      if (WindowReversal != false) {
        size += 1 + 1;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(WindowDimension other) {
      if (other == null) {
        return;
      }
      if (other.Size != 0L) {
        Size = other.Size;
      }
      if (other.Stride != 0L) {
        Stride = other.Stride;
      }
      if (other.PaddingLow != 0L) {
        PaddingLow = other.PaddingLow;
      }
      if (other.PaddingHigh != 0L) {
        PaddingHigh = other.PaddingHigh;
      }
      if (other.WindowDilation != 0L) {
        WindowDilation = other.WindowDilation;
      }
      if (other.BaseDilation != 0L) {
        BaseDilation = other.BaseDilation;
      }
      if (other.WindowReversal != false) {
        WindowReversal = other.WindowReversal;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            Size = input.ReadInt64();
            break;
          }
          case 16: {
            Stride = input.ReadInt64();
            break;
          }
          case 24: {
            PaddingLow = input.ReadInt64();
            break;
          }
          case 32: {
            PaddingHigh = input.ReadInt64();
            break;
          }
          case 40: {
            WindowDilation = input.ReadInt64();
            break;
          }
          case 48: {
            BaseDilation = input.ReadInt64();
            break;
          }
          case 56: {
            WindowReversal = input.ReadBool();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// Describes the windowing in an operation such as convolution.
  ///
  /// The window is moved across a base area and for each position of the
  /// window a computation is performed. The field below describes the
  /// window and the movement of the window across a base area.
  /// </summary>
  public sealed partial class Window : pb::IMessage<Window> {
    private static readonly pb::MessageParser<Window> _parser = new pb::MessageParser<Window>(() => new Window());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<Window> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Xla.XlaDataReflection.Descriptor.MessageTypes[15]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Window() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Window(Window other) : this() {
      dimensions_ = other.dimensions_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Window Clone() {
      return new Window(this);
    }

    /// <summary>Field number for the "dimensions" field.</summary>
    public const int DimensionsFieldNumber = 1;
    private static readonly pb::FieldCodec<global::Xla.WindowDimension> _repeated_dimensions_codec
        = pb::FieldCodec.ForMessage(10, global::Xla.WindowDimension.Parser);
    private readonly pbc::RepeatedField<global::Xla.WindowDimension> dimensions_ = new pbc::RepeatedField<global::Xla.WindowDimension>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Xla.WindowDimension> Dimensions {
      get { return dimensions_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as Window);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(Window other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!dimensions_.Equals(other.dimensions_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= dimensions_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      dimensions_.WriteTo(output, _repeated_dimensions_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      size += dimensions_.CalculateSize(_repeated_dimensions_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(Window other) {
      if (other == null) {
        return;
      }
      dimensions_.Add(other.dimensions_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            dimensions_.AddEntriesFrom(input, _repeated_dimensions_codec);
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// Describes the dimension numbers for a gather operation.
  ///
  /// See https://www.tensorflow.org/performance/xla/operation_semantics#gather for
  /// more details.
  /// </summary>
  public sealed partial class GatherDimensionNumbers : pb::IMessage<GatherDimensionNumbers> {
    private static readonly pb::MessageParser<GatherDimensionNumbers> _parser = new pb::MessageParser<GatherDimensionNumbers>(() => new GatherDimensionNumbers());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<GatherDimensionNumbers> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Xla.XlaDataReflection.Descriptor.MessageTypes[16]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public GatherDimensionNumbers() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public GatherDimensionNumbers(GatherDimensionNumbers other) : this() {
      offsetDims_ = other.offsetDims_.Clone();
      collapsedSliceDims_ = other.collapsedSliceDims_.Clone();
      startIndexMap_ = other.startIndexMap_.Clone();
      indexVectorDim_ = other.indexVectorDim_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public GatherDimensionNumbers Clone() {
      return new GatherDimensionNumbers(this);
    }

    /// <summary>Field number for the "offset_dims" field.</summary>
    public const int OffsetDimsFieldNumber = 1;
    private static readonly pb::FieldCodec<long> _repeated_offsetDims_codec
        = pb::FieldCodec.ForInt64(10);
    private readonly pbc::RepeatedField<long> offsetDims_ = new pbc::RepeatedField<long>();
    /// <summary>
    /// "Window indices" is a term for a set of indices that index into the
    /// interior of a dynamic-slice from the input tensor, the starting indices for
    /// which were computed from output_gather_dims (see the operation semantic for
    /// how this is defined) and the start_indices tensor.
    ///
    /// The window indices for a specific output index Out is computed as:
    ///
    ///  i = 0
    ///  for (k : [0, input_tensor_shape.rank))
    ///    window_indices[k] =
    ///      if k in collapsed_slice_dims
    ///      then 0
    ///      else Out[offset_dims[i++]]
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<long> OffsetDims {
      get { return offsetDims_; }
    }

    /// <summary>Field number for the "collapsed_slice_dims" field.</summary>
    public const int CollapsedSliceDimsFieldNumber = 2;
    private static readonly pb::FieldCodec<long> _repeated_collapsedSliceDims_codec
        = pb::FieldCodec.ForInt64(18);
    private readonly pbc::RepeatedField<long> collapsedSliceDims_ = new pbc::RepeatedField<long>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<long> CollapsedSliceDims {
      get { return collapsedSliceDims_; }
    }

    /// <summary>Field number for the "start_index_map" field.</summary>
    public const int StartIndexMapFieldNumber = 3;
    private static readonly pb::FieldCodec<long> _repeated_startIndexMap_codec
        = pb::FieldCodec.ForInt64(26);
    private readonly pbc::RepeatedField<long> startIndexMap_ = new pbc::RepeatedField<long>();
    /// <summary>
    /// This is interpreted as a map from i to start_index_map[i]. It
    /// transforms the gather index looked up from the start_indices tensor into
    /// the starting index in the input space.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<long> StartIndexMap {
      get { return startIndexMap_; }
    }

    /// <summary>Field number for the "index_vector_dim" field.</summary>
    public const int IndexVectorDimFieldNumber = 4;
    private long indexVectorDim_;
    /// <summary>
    /// The dimension in the start_indices input that contains the starting
    /// indices.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long IndexVectorDim {
      get { return indexVectorDim_; }
      set {
        indexVectorDim_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as GatherDimensionNumbers);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(GatherDimensionNumbers other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!offsetDims_.Equals(other.offsetDims_)) return false;
      if(!collapsedSliceDims_.Equals(other.collapsedSliceDims_)) return false;
      if(!startIndexMap_.Equals(other.startIndexMap_)) return false;
      if (IndexVectorDim != other.IndexVectorDim) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= offsetDims_.GetHashCode();
      hash ^= collapsedSliceDims_.GetHashCode();
      hash ^= startIndexMap_.GetHashCode();
      if (IndexVectorDim != 0L) hash ^= IndexVectorDim.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      offsetDims_.WriteTo(output, _repeated_offsetDims_codec);
      collapsedSliceDims_.WriteTo(output, _repeated_collapsedSliceDims_codec);
      startIndexMap_.WriteTo(output, _repeated_startIndexMap_codec);
      if (IndexVectorDim != 0L) {
        output.WriteRawTag(32);
        output.WriteInt64(IndexVectorDim);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      size += offsetDims_.CalculateSize(_repeated_offsetDims_codec);
      size += collapsedSliceDims_.CalculateSize(_repeated_collapsedSliceDims_codec);
      size += startIndexMap_.CalculateSize(_repeated_startIndexMap_codec);
      if (IndexVectorDim != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(IndexVectorDim);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(GatherDimensionNumbers other) {
      if (other == null) {
        return;
      }
      offsetDims_.Add(other.offsetDims_);
      collapsedSliceDims_.Add(other.collapsedSliceDims_);
      startIndexMap_.Add(other.startIndexMap_);
      if (other.IndexVectorDim != 0L) {
        IndexVectorDim = other.IndexVectorDim;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10:
          case 8: {
            offsetDims_.AddEntriesFrom(input, _repeated_offsetDims_codec);
            break;
          }
          case 18:
          case 16: {
            collapsedSliceDims_.AddEntriesFrom(input, _repeated_collapsedSliceDims_codec);
            break;
          }
          case 26:
          case 24: {
            startIndexMap_.AddEntriesFrom(input, _repeated_startIndexMap_codec);
            break;
          }
          case 32: {
            IndexVectorDim = input.ReadInt64();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// Describes the dimension numbers for a scatter operation.
  ///
  /// All the fields are similar to the corresponding fields in
  /// GatherDimensionNumbers. Differences are noted below.
  /// </summary>
  public sealed partial class ScatterDimensionNumbers : pb::IMessage<ScatterDimensionNumbers> {
    private static readonly pb::MessageParser<ScatterDimensionNumbers> _parser = new pb::MessageParser<ScatterDimensionNumbers>(() => new ScatterDimensionNumbers());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ScatterDimensionNumbers> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Xla.XlaDataReflection.Descriptor.MessageTypes[17]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ScatterDimensionNumbers() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ScatterDimensionNumbers(ScatterDimensionNumbers other) : this() {
      updateWindowDims_ = other.updateWindowDims_.Clone();
      insertedWindowDims_ = other.insertedWindowDims_.Clone();
      scatterDimsToOperandDims_ = other.scatterDimsToOperandDims_.Clone();
      indexVectorDim_ = other.indexVectorDim_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ScatterDimensionNumbers Clone() {
      return new ScatterDimensionNumbers(this);
    }

    /// <summary>Field number for the "update_window_dims" field.</summary>
    public const int UpdateWindowDimsFieldNumber = 1;
    private static readonly pb::FieldCodec<long> _repeated_updateWindowDims_codec
        = pb::FieldCodec.ForInt64(10);
    private readonly pbc::RepeatedField<long> updateWindowDims_ = new pbc::RepeatedField<long>();
    /// <summary>
    /// The set of dimensions in the updates shape that are window dimensions.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<long> UpdateWindowDims {
      get { return updateWindowDims_; }
    }

    /// <summary>Field number for the "inserted_window_dims" field.</summary>
    public const int InsertedWindowDimsFieldNumber = 2;
    private static readonly pb::FieldCodec<long> _repeated_insertedWindowDims_codec
        = pb::FieldCodec.ForInt64(18);
    private readonly pbc::RepeatedField<long> insertedWindowDims_ = new pbc::RepeatedField<long>();
    /// <summary>
    /// The set of window dimensions that must be inserted into the updates shape.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<long> InsertedWindowDims {
      get { return insertedWindowDims_; }
    }

    /// <summary>Field number for the "scatter_dims_to_operand_dims" field.</summary>
    public const int ScatterDimsToOperandDimsFieldNumber = 3;
    private static readonly pb::FieldCodec<long> _repeated_scatterDimsToOperandDims_codec
        = pb::FieldCodec.ForInt64(26);
    private readonly pbc::RepeatedField<long> scatterDimsToOperandDims_ = new pbc::RepeatedField<long>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<long> ScatterDimsToOperandDims {
      get { return scatterDimsToOperandDims_; }
    }

    /// <summary>Field number for the "index_vector_dim" field.</summary>
    public const int IndexVectorDimFieldNumber = 4;
    private long indexVectorDim_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long IndexVectorDim {
      get { return indexVectorDim_; }
      set {
        indexVectorDim_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ScatterDimensionNumbers);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ScatterDimensionNumbers other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!updateWindowDims_.Equals(other.updateWindowDims_)) return false;
      if(!insertedWindowDims_.Equals(other.insertedWindowDims_)) return false;
      if(!scatterDimsToOperandDims_.Equals(other.scatterDimsToOperandDims_)) return false;
      if (IndexVectorDim != other.IndexVectorDim) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= updateWindowDims_.GetHashCode();
      hash ^= insertedWindowDims_.GetHashCode();
      hash ^= scatterDimsToOperandDims_.GetHashCode();
      if (IndexVectorDim != 0L) hash ^= IndexVectorDim.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      updateWindowDims_.WriteTo(output, _repeated_updateWindowDims_codec);
      insertedWindowDims_.WriteTo(output, _repeated_insertedWindowDims_codec);
      scatterDimsToOperandDims_.WriteTo(output, _repeated_scatterDimsToOperandDims_codec);
      if (IndexVectorDim != 0L) {
        output.WriteRawTag(32);
        output.WriteInt64(IndexVectorDim);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      size += updateWindowDims_.CalculateSize(_repeated_updateWindowDims_codec);
      size += insertedWindowDims_.CalculateSize(_repeated_insertedWindowDims_codec);
      size += scatterDimsToOperandDims_.CalculateSize(_repeated_scatterDimsToOperandDims_codec);
      if (IndexVectorDim != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(IndexVectorDim);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ScatterDimensionNumbers other) {
      if (other == null) {
        return;
      }
      updateWindowDims_.Add(other.updateWindowDims_);
      insertedWindowDims_.Add(other.insertedWindowDims_);
      scatterDimsToOperandDims_.Add(other.scatterDimsToOperandDims_);
      if (other.IndexVectorDim != 0L) {
        IndexVectorDim = other.IndexVectorDim;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10:
          case 8: {
            updateWindowDims_.AddEntriesFrom(input, _repeated_updateWindowDims_codec);
            break;
          }
          case 18:
          case 16: {
            insertedWindowDims_.AddEntriesFrom(input, _repeated_insertedWindowDims_codec);
            break;
          }
          case 26:
          case 24: {
            scatterDimsToOperandDims_.AddEntriesFrom(input, _repeated_scatterDimsToOperandDims_codec);
            break;
          }
          case 32: {
            IndexVectorDim = input.ReadInt64();
            break;
          }
        }
      }
    }

  }

  public sealed partial class ConvolutionDimensionNumbers : pb::IMessage<ConvolutionDimensionNumbers> {
    private static readonly pb::MessageParser<ConvolutionDimensionNumbers> _parser = new pb::MessageParser<ConvolutionDimensionNumbers>(() => new ConvolutionDimensionNumbers());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ConvolutionDimensionNumbers> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Xla.XlaDataReflection.Descriptor.MessageTypes[18]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ConvolutionDimensionNumbers() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ConvolutionDimensionNumbers(ConvolutionDimensionNumbers other) : this() {
      inputBatchDimension_ = other.inputBatchDimension_;
      inputFeatureDimension_ = other.inputFeatureDimension_;
      inputSpatialDimensions_ = other.inputSpatialDimensions_.Clone();
      kernelInputFeatureDimension_ = other.kernelInputFeatureDimension_;
      kernelOutputFeatureDimension_ = other.kernelOutputFeatureDimension_;
      kernelSpatialDimensions_ = other.kernelSpatialDimensions_.Clone();
      outputBatchDimension_ = other.outputBatchDimension_;
      outputFeatureDimension_ = other.outputFeatureDimension_;
      outputSpatialDimensions_ = other.outputSpatialDimensions_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ConvolutionDimensionNumbers Clone() {
      return new ConvolutionDimensionNumbers(this);
    }

    /// <summary>Field number for the "input_batch_dimension" field.</summary>
    public const int InputBatchDimensionFieldNumber = 7;
    private long inputBatchDimension_;
    /// <summary>
    /// The number of the dimension that represents batch in the input.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long InputBatchDimension {
      get { return inputBatchDimension_; }
      set {
        inputBatchDimension_ = value;
      }
    }

    /// <summary>Field number for the "input_feature_dimension" field.</summary>
    public const int InputFeatureDimensionFieldNumber = 8;
    private long inputFeatureDimension_;
    /// <summary>
    /// The number of the dimension that represents features in the input.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long InputFeatureDimension {
      get { return inputFeatureDimension_; }
      set {
        inputFeatureDimension_ = value;
      }
    }

    /// <summary>Field number for the "input_spatial_dimensions" field.</summary>
    public const int InputSpatialDimensionsFieldNumber = 11;
    private static readonly pb::FieldCodec<long> _repeated_inputSpatialDimensions_codec
        = pb::FieldCodec.ForInt64(90);
    private readonly pbc::RepeatedField<long> inputSpatialDimensions_ = new pbc::RepeatedField<long>();
    /// <summary>
    /// The dimension numbers for the spatial dimensions that the window
    /// moves through in the input.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<long> InputSpatialDimensions {
      get { return inputSpatialDimensions_; }
    }

    /// <summary>Field number for the "kernel_input_feature_dimension" field.</summary>
    public const int KernelInputFeatureDimensionFieldNumber = 3;
    private long kernelInputFeatureDimension_;
    /// <summary>
    /// The number of the dimension that represents input features in the
    /// convolutional kernel (rhs).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long KernelInputFeatureDimension {
      get { return kernelInputFeatureDimension_; }
      set {
        kernelInputFeatureDimension_ = value;
      }
    }

    /// <summary>Field number for the "kernel_output_feature_dimension" field.</summary>
    public const int KernelOutputFeatureDimensionFieldNumber = 4;
    private long kernelOutputFeatureDimension_;
    /// <summary>
    /// The number of the dimension that represents output features in
    /// the convolutional kernel (rhs).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long KernelOutputFeatureDimension {
      get { return kernelOutputFeatureDimension_; }
      set {
        kernelOutputFeatureDimension_ = value;
      }
    }

    /// <summary>Field number for the "kernel_spatial_dimensions" field.</summary>
    public const int KernelSpatialDimensionsFieldNumber = 6;
    private static readonly pb::FieldCodec<long> _repeated_kernelSpatialDimensions_codec
        = pb::FieldCodec.ForInt64(50);
    private readonly pbc::RepeatedField<long> kernelSpatialDimensions_ = new pbc::RepeatedField<long>();
    /// <summary>
    /// The dimension numbers for the spatial dimensions that the window
    /// moves through in the kernel (rhs). window.strides(0) is the
    /// stride in the kernel_spatial_dimensions(0) dimension.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<long> KernelSpatialDimensions {
      get { return kernelSpatialDimensions_; }
    }

    /// <summary>Field number for the "output_batch_dimension" field.</summary>
    public const int OutputBatchDimensionFieldNumber = 9;
    private long outputBatchDimension_;
    /// <summary>
    /// The number of the dimension that represents batch in the output.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long OutputBatchDimension {
      get { return outputBatchDimension_; }
      set {
        outputBatchDimension_ = value;
      }
    }

    /// <summary>Field number for the "output_feature_dimension" field.</summary>
    public const int OutputFeatureDimensionFieldNumber = 10;
    private long outputFeatureDimension_;
    /// <summary>
    /// The number of the dimension that represents features in the output.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long OutputFeatureDimension {
      get { return outputFeatureDimension_; }
      set {
        outputFeatureDimension_ = value;
      }
    }

    /// <summary>Field number for the "output_spatial_dimensions" field.</summary>
    public const int OutputSpatialDimensionsFieldNumber = 12;
    private static readonly pb::FieldCodec<long> _repeated_outputSpatialDimensions_codec
        = pb::FieldCodec.ForInt64(98);
    private readonly pbc::RepeatedField<long> outputSpatialDimensions_ = new pbc::RepeatedField<long>();
    /// <summary>
    /// The dimension numbers for the spatial dimensions that the window
    /// moves through in the output.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<long> OutputSpatialDimensions {
      get { return outputSpatialDimensions_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ConvolutionDimensionNumbers);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ConvolutionDimensionNumbers other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (InputBatchDimension != other.InputBatchDimension) return false;
      if (InputFeatureDimension != other.InputFeatureDimension) return false;
      if(!inputSpatialDimensions_.Equals(other.inputSpatialDimensions_)) return false;
      if (KernelInputFeatureDimension != other.KernelInputFeatureDimension) return false;
      if (KernelOutputFeatureDimension != other.KernelOutputFeatureDimension) return false;
      if(!kernelSpatialDimensions_.Equals(other.kernelSpatialDimensions_)) return false;
      if (OutputBatchDimension != other.OutputBatchDimension) return false;
      if (OutputFeatureDimension != other.OutputFeatureDimension) return false;
      if(!outputSpatialDimensions_.Equals(other.outputSpatialDimensions_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (InputBatchDimension != 0L) hash ^= InputBatchDimension.GetHashCode();
      if (InputFeatureDimension != 0L) hash ^= InputFeatureDimension.GetHashCode();
      hash ^= inputSpatialDimensions_.GetHashCode();
      if (KernelInputFeatureDimension != 0L) hash ^= KernelInputFeatureDimension.GetHashCode();
      if (KernelOutputFeatureDimension != 0L) hash ^= KernelOutputFeatureDimension.GetHashCode();
      hash ^= kernelSpatialDimensions_.GetHashCode();
      if (OutputBatchDimension != 0L) hash ^= OutputBatchDimension.GetHashCode();
      if (OutputFeatureDimension != 0L) hash ^= OutputFeatureDimension.GetHashCode();
      hash ^= outputSpatialDimensions_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (KernelInputFeatureDimension != 0L) {
        output.WriteRawTag(24);
        output.WriteInt64(KernelInputFeatureDimension);
      }
      if (KernelOutputFeatureDimension != 0L) {
        output.WriteRawTag(32);
        output.WriteInt64(KernelOutputFeatureDimension);
      }
      kernelSpatialDimensions_.WriteTo(output, _repeated_kernelSpatialDimensions_codec);
      if (InputBatchDimension != 0L) {
        output.WriteRawTag(56);
        output.WriteInt64(InputBatchDimension);
      }
      if (InputFeatureDimension != 0L) {
        output.WriteRawTag(64);
        output.WriteInt64(InputFeatureDimension);
      }
      if (OutputBatchDimension != 0L) {
        output.WriteRawTag(72);
        output.WriteInt64(OutputBatchDimension);
      }
      if (OutputFeatureDimension != 0L) {
        output.WriteRawTag(80);
        output.WriteInt64(OutputFeatureDimension);
      }
      inputSpatialDimensions_.WriteTo(output, _repeated_inputSpatialDimensions_codec);
      outputSpatialDimensions_.WriteTo(output, _repeated_outputSpatialDimensions_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (InputBatchDimension != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(InputBatchDimension);
      }
      if (InputFeatureDimension != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(InputFeatureDimension);
      }
      size += inputSpatialDimensions_.CalculateSize(_repeated_inputSpatialDimensions_codec);
      if (KernelInputFeatureDimension != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(KernelInputFeatureDimension);
      }
      if (KernelOutputFeatureDimension != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(KernelOutputFeatureDimension);
      }
      size += kernelSpatialDimensions_.CalculateSize(_repeated_kernelSpatialDimensions_codec);
      if (OutputBatchDimension != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(OutputBatchDimension);
      }
      if (OutputFeatureDimension != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(OutputFeatureDimension);
      }
      size += outputSpatialDimensions_.CalculateSize(_repeated_outputSpatialDimensions_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ConvolutionDimensionNumbers other) {
      if (other == null) {
        return;
      }
      if (other.InputBatchDimension != 0L) {
        InputBatchDimension = other.InputBatchDimension;
      }
      if (other.InputFeatureDimension != 0L) {
        InputFeatureDimension = other.InputFeatureDimension;
      }
      inputSpatialDimensions_.Add(other.inputSpatialDimensions_);
      if (other.KernelInputFeatureDimension != 0L) {
        KernelInputFeatureDimension = other.KernelInputFeatureDimension;
      }
      if (other.KernelOutputFeatureDimension != 0L) {
        KernelOutputFeatureDimension = other.KernelOutputFeatureDimension;
      }
      kernelSpatialDimensions_.Add(other.kernelSpatialDimensions_);
      if (other.OutputBatchDimension != 0L) {
        OutputBatchDimension = other.OutputBatchDimension;
      }
      if (other.OutputFeatureDimension != 0L) {
        OutputFeatureDimension = other.OutputFeatureDimension;
      }
      outputSpatialDimensions_.Add(other.outputSpatialDimensions_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 24: {
            KernelInputFeatureDimension = input.ReadInt64();
            break;
          }
          case 32: {
            KernelOutputFeatureDimension = input.ReadInt64();
            break;
          }
          case 50:
          case 48: {
            kernelSpatialDimensions_.AddEntriesFrom(input, _repeated_kernelSpatialDimensions_codec);
            break;
          }
          case 56: {
            InputBatchDimension = input.ReadInt64();
            break;
          }
          case 64: {
            InputFeatureDimension = input.ReadInt64();
            break;
          }
          case 72: {
            OutputBatchDimension = input.ReadInt64();
            break;
          }
          case 80: {
            OutputFeatureDimension = input.ReadInt64();
            break;
          }
          case 90:
          case 88: {
            inputSpatialDimensions_.AddEntriesFrom(input, _repeated_inputSpatialDimensions_codec);
            break;
          }
          case 98:
          case 96: {
            outputSpatialDimensions_.AddEntriesFrom(input, _repeated_outputSpatialDimensions_codec);
            break;
          }
        }
      }
    }

  }

  public sealed partial class DotDimensionNumbers : pb::IMessage<DotDimensionNumbers> {
    private static readonly pb::MessageParser<DotDimensionNumbers> _parser = new pb::MessageParser<DotDimensionNumbers>(() => new DotDimensionNumbers());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<DotDimensionNumbers> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Xla.XlaDataReflection.Descriptor.MessageTypes[19]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public DotDimensionNumbers() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public DotDimensionNumbers(DotDimensionNumbers other) : this() {
      lhsContractingDimensions_ = other.lhsContractingDimensions_.Clone();
      rhsContractingDimensions_ = other.rhsContractingDimensions_.Clone();
      lhsBatchDimensions_ = other.lhsBatchDimensions_.Clone();
      rhsBatchDimensions_ = other.rhsBatchDimensions_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public DotDimensionNumbers Clone() {
      return new DotDimensionNumbers(this);
    }

    /// <summary>Field number for the "lhs_contracting_dimensions" field.</summary>
    public const int LhsContractingDimensionsFieldNumber = 1;
    private static readonly pb::FieldCodec<long> _repeated_lhsContractingDimensions_codec
        = pb::FieldCodec.ForInt64(10);
    private readonly pbc::RepeatedField<long> lhsContractingDimensions_ = new pbc::RepeatedField<long>();
    /// <summary>
    /// The dimension numbers that represent the 'lhs' contracting dimensions.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<long> LhsContractingDimensions {
      get { return lhsContractingDimensions_; }
    }

    /// <summary>Field number for the "rhs_contracting_dimensions" field.</summary>
    public const int RhsContractingDimensionsFieldNumber = 2;
    private static readonly pb::FieldCodec<long> _repeated_rhsContractingDimensions_codec
        = pb::FieldCodec.ForInt64(18);
    private readonly pbc::RepeatedField<long> rhsContractingDimensions_ = new pbc::RepeatedField<long>();
    /// <summary>
    /// The dimension numbers that represent the 'rhs' contracting dimensions.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<long> RhsContractingDimensions {
      get { return rhsContractingDimensions_; }
    }

    /// <summary>Field number for the "lhs_batch_dimensions" field.</summary>
    public const int LhsBatchDimensionsFieldNumber = 3;
    private static readonly pb::FieldCodec<long> _repeated_lhsBatchDimensions_codec
        = pb::FieldCodec.ForInt64(26);
    private readonly pbc::RepeatedField<long> lhsBatchDimensions_ = new pbc::RepeatedField<long>();
    /// <summary>
    /// The dimension numbers that represent the 'lhs' batch dimensions.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<long> LhsBatchDimensions {
      get { return lhsBatchDimensions_; }
    }

    /// <summary>Field number for the "rhs_batch_dimensions" field.</summary>
    public const int RhsBatchDimensionsFieldNumber = 4;
    private static readonly pb::FieldCodec<long> _repeated_rhsBatchDimensions_codec
        = pb::FieldCodec.ForInt64(34);
    private readonly pbc::RepeatedField<long> rhsBatchDimensions_ = new pbc::RepeatedField<long>();
    /// <summary>
    /// The dimension numbers that represent the 'rhs' batch dimensions.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<long> RhsBatchDimensions {
      get { return rhsBatchDimensions_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as DotDimensionNumbers);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(DotDimensionNumbers other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!lhsContractingDimensions_.Equals(other.lhsContractingDimensions_)) return false;
      if(!rhsContractingDimensions_.Equals(other.rhsContractingDimensions_)) return false;
      if(!lhsBatchDimensions_.Equals(other.lhsBatchDimensions_)) return false;
      if(!rhsBatchDimensions_.Equals(other.rhsBatchDimensions_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= lhsContractingDimensions_.GetHashCode();
      hash ^= rhsContractingDimensions_.GetHashCode();
      hash ^= lhsBatchDimensions_.GetHashCode();
      hash ^= rhsBatchDimensions_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      lhsContractingDimensions_.WriteTo(output, _repeated_lhsContractingDimensions_codec);
      rhsContractingDimensions_.WriteTo(output, _repeated_rhsContractingDimensions_codec);
      lhsBatchDimensions_.WriteTo(output, _repeated_lhsBatchDimensions_codec);
      rhsBatchDimensions_.WriteTo(output, _repeated_rhsBatchDimensions_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      size += lhsContractingDimensions_.CalculateSize(_repeated_lhsContractingDimensions_codec);
      size += rhsContractingDimensions_.CalculateSize(_repeated_rhsContractingDimensions_codec);
      size += lhsBatchDimensions_.CalculateSize(_repeated_lhsBatchDimensions_codec);
      size += rhsBatchDimensions_.CalculateSize(_repeated_rhsBatchDimensions_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(DotDimensionNumbers other) {
      if (other == null) {
        return;
      }
      lhsContractingDimensions_.Add(other.lhsContractingDimensions_);
      rhsContractingDimensions_.Add(other.rhsContractingDimensions_);
      lhsBatchDimensions_.Add(other.lhsBatchDimensions_);
      rhsBatchDimensions_.Add(other.rhsBatchDimensions_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10:
          case 8: {
            lhsContractingDimensions_.AddEntriesFrom(input, _repeated_lhsContractingDimensions_codec);
            break;
          }
          case 18:
          case 16: {
            rhsContractingDimensions_.AddEntriesFrom(input, _repeated_rhsContractingDimensions_codec);
            break;
          }
          case 26:
          case 24: {
            lhsBatchDimensions_.AddEntriesFrom(input, _repeated_lhsBatchDimensions_codec);
            break;
          }
          case 34:
          case 32: {
            rhsBatchDimensions_.AddEntriesFrom(input, _repeated_rhsBatchDimensions_codec);
            break;
          }
        }
      }
    }

  }

  public sealed partial class TriangularSolveOptions : pb::IMessage<TriangularSolveOptions> {
    private static readonly pb::MessageParser<TriangularSolveOptions> _parser = new pb::MessageParser<TriangularSolveOptions>(() => new TriangularSolveOptions());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<TriangularSolveOptions> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Xla.XlaDataReflection.Descriptor.MessageTypes[20]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TriangularSolveOptions() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TriangularSolveOptions(TriangularSolveOptions other) : this() {
      leftSide_ = other.leftSide_;
      lower_ = other.lower_;
      unitDiagonal_ = other.unitDiagonal_;
      transposeA_ = other.transposeA_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TriangularSolveOptions Clone() {
      return new TriangularSolveOptions(this);
    }

    /// <summary>Field number for the "left_side" field.</summary>
    public const int LeftSideFieldNumber = 1;
    private bool leftSide_;
    /// <summary>
    /// If true, solves ax = b. If false, solves xa = b.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool LeftSide {
      get { return leftSide_; }
      set {
        leftSide_ = value;
      }
    }

    /// <summary>Field number for the "lower" field.</summary>
    public const int LowerFieldNumber = 2;
    private bool lower_;
    /// <summary>
    /// If true, 'a' is lower triangular. If false, 'a' is upper triangular.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Lower {
      get { return lower_; }
      set {
        lower_ = value;
      }
    }

    /// <summary>Field number for the "unit_diagonal" field.</summary>
    public const int UnitDiagonalFieldNumber = 3;
    private bool unitDiagonal_;
    /// <summary>
    /// If true, the diagonal elements of 'a' are assumed to be 1 and not accessed.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool UnitDiagonal {
      get { return unitDiagonal_; }
      set {
        unitDiagonal_ = value;
      }
    }

    /// <summary>Field number for the "transpose_a" field.</summary>
    public const int TransposeAFieldNumber = 4;
    private global::Xla.TriangularSolveOptions.Types.Transpose transposeA_ = 0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Xla.TriangularSolveOptions.Types.Transpose TransposeA {
      get { return transposeA_; }
      set {
        transposeA_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as TriangularSolveOptions);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(TriangularSolveOptions other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (LeftSide != other.LeftSide) return false;
      if (Lower != other.Lower) return false;
      if (UnitDiagonal != other.UnitDiagonal) return false;
      if (TransposeA != other.TransposeA) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (LeftSide != false) hash ^= LeftSide.GetHashCode();
      if (Lower != false) hash ^= Lower.GetHashCode();
      if (UnitDiagonal != false) hash ^= UnitDiagonal.GetHashCode();
      if (TransposeA != 0) hash ^= TransposeA.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (LeftSide != false) {
        output.WriteRawTag(8);
        output.WriteBool(LeftSide);
      }
      if (Lower != false) {
        output.WriteRawTag(16);
        output.WriteBool(Lower);
      }
      if (UnitDiagonal != false) {
        output.WriteRawTag(24);
        output.WriteBool(UnitDiagonal);
      }
      if (TransposeA != 0) {
        output.WriteRawTag(32);
        output.WriteEnum((int) TransposeA);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (LeftSide != false) {
        size += 1 + 1;
      }
      if (Lower != false) {
        size += 1 + 1;
      }
      if (UnitDiagonal != false) {
        size += 1 + 1;
      }
      if (TransposeA != 0) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) TransposeA);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(TriangularSolveOptions other) {
      if (other == null) {
        return;
      }
      if (other.LeftSide != false) {
        LeftSide = other.LeftSide;
      }
      if (other.Lower != false) {
        Lower = other.Lower;
      }
      if (other.UnitDiagonal != false) {
        UnitDiagonal = other.UnitDiagonal;
      }
      if (other.TransposeA != 0) {
        TransposeA = other.TransposeA;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            LeftSide = input.ReadBool();
            break;
          }
          case 16: {
            Lower = input.ReadBool();
            break;
          }
          case 24: {
            UnitDiagonal = input.ReadBool();
            break;
          }
          case 32: {
            TransposeA = (global::Xla.TriangularSolveOptions.Types.Transpose) input.ReadEnum();
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the TriangularSolveOptions message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      /// <summary>
      /// Should we transpose or use the adjoint of 'a'?
      /// </summary>
      public enum Transpose {
        [pbr::OriginalName("TRANSPOSE_INVALID")] Invalid = 0,
        /// <summary>
        /// Don't transpose 'a'.
        /// </summary>
        [pbr::OriginalName("NO_TRANSPOSE")] NoTranspose = 1,
        /// <summary>
        /// Transpose 'a'.
        /// </summary>
        [pbr::OriginalName("TRANSPOSE")] Transpose = 2,
        /// <summary>
        /// Complex conjugate and transpose 'a'.
        /// </summary>
        [pbr::OriginalName("ADJOINT")] Adjoint = 3,
      }

    }
    #endregion

  }

  public sealed partial class CholeskyOptions : pb::IMessage<CholeskyOptions> {
    private static readonly pb::MessageParser<CholeskyOptions> _parser = new pb::MessageParser<CholeskyOptions>(() => new CholeskyOptions());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<CholeskyOptions> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Xla.XlaDataReflection.Descriptor.MessageTypes[21]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public CholeskyOptions() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public CholeskyOptions(CholeskyOptions other) : this() {
      lower_ = other.lower_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public CholeskyOptions Clone() {
      return new CholeskyOptions(this);
    }

    /// <summary>Field number for the "lower" field.</summary>
    public const int LowerFieldNumber = 1;
    private bool lower_;
    /// <summary>
    /// If true, uses the lower triangle of `a`. If false, uses the upper triangle
    /// of `a`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Lower {
      get { return lower_; }
      set {
        lower_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as CholeskyOptions);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(CholeskyOptions other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Lower != other.Lower) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Lower != false) hash ^= Lower.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Lower != false) {
        output.WriteRawTag(8);
        output.WriteBool(Lower);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Lower != false) {
        size += 1 + 1;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(CholeskyOptions other) {
      if (other == null) {
        return;
      }
      if (other.Lower != false) {
        Lower = other.Lower;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            Lower = input.ReadBool();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// Generic map of attributes used to pass hints / configuration options from
  /// the Python frontend to the XLA backend.
  /// </summary>
  public sealed partial class FrontendAttributes : pb::IMessage<FrontendAttributes> {
    private static readonly pb::MessageParser<FrontendAttributes> _parser = new pb::MessageParser<FrontendAttributes>(() => new FrontendAttributes());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<FrontendAttributes> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Xla.XlaDataReflection.Descriptor.MessageTypes[22]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public FrontendAttributes() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public FrontendAttributes(FrontendAttributes other) : this() {
      map_ = other.map_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public FrontendAttributes Clone() {
      return new FrontendAttributes(this);
    }

    /// <summary>Field number for the "map" field.</summary>
    public const int MapFieldNumber = 1;
    private static readonly pbc::MapField<string, string>.Codec _map_map_codec
        = new pbc::MapField<string, string>.Codec(pb::FieldCodec.ForString(10), pb::FieldCodec.ForString(18), 10);
    private readonly pbc::MapField<string, string> map_ = new pbc::MapField<string, string>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::MapField<string, string> Map {
      get { return map_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as FrontendAttributes);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(FrontendAttributes other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!Map.Equals(other.Map)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= Map.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      map_.WriteTo(output, _map_map_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      size += map_.CalculateSize(_map_map_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(FrontendAttributes other) {
      if (other == null) {
        return;
      }
      map_.Add(other.map_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            map_.AddEntriesFrom(input, _map_map_codec);
            break;
          }
        }
      }
    }

  }

  public sealed partial class OpSharding : pb::IMessage<OpSharding> {
    private static readonly pb::MessageParser<OpSharding> _parser = new pb::MessageParser<OpSharding>(() => new OpSharding());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<OpSharding> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Xla.XlaDataReflection.Descriptor.MessageTypes[23]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public OpSharding() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public OpSharding(OpSharding other) : this() {
      type_ = other.type_;
      tileShape_ = other.tileShape_ != null ? other.tileShape_.Clone() : null;
      tileAssignmentDimensions_ = other.tileAssignmentDimensions_.Clone();
      tileAssignmentDevices_ = other.tileAssignmentDevices_.Clone();
      tupleShardings_ = other.tupleShardings_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public OpSharding Clone() {
      return new OpSharding(this);
    }

    /// <summary>Field number for the "type" field.</summary>
    public const int TypeFieldNumber = 1;
    private global::Xla.OpSharding.Types.Type type_ = 0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Xla.OpSharding.Types.Type Type {
      get { return type_; }
      set {
        type_ = value;
      }
    }

    /// <summary>Field number for the "tile_shape" field.</summary>
    public const int TileShapeFieldNumber = 2;
    private global::Xla.ShapeProto tileShape_;
    /// <summary>
    /// The shape of the sharded tile.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Xla.ShapeProto TileShape {
      get { return tileShape_; }
      set {
        tileShape_ = value;
      }
    }

    /// <summary>Field number for the "tile_assignment_dimensions" field.</summary>
    public const int TileAssignmentDimensionsFieldNumber = 3;
    private static readonly pb::FieldCodec<long> _repeated_tileAssignmentDimensions_codec
        = pb::FieldCodec.ForInt64(26);
    private readonly pbc::RepeatedField<long> tileAssignmentDimensions_ = new pbc::RepeatedField<long>();
    /// <summary>
    /// The shape of the tile assignment tensor - this must be the same rank as
    /// tile_shape and the product of its dimensions must equal
    /// tile_assignment_devices.size().
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<long> TileAssignmentDimensions {
      get { return tileAssignmentDimensions_; }
    }

    /// <summary>Field number for the "tile_assignment_devices" field.</summary>
    public const int TileAssignmentDevicesFieldNumber = 4;
    private static readonly pb::FieldCodec<long> _repeated_tileAssignmentDevices_codec
        = pb::FieldCodec.ForInt64(34);
    private readonly pbc::RepeatedField<long> tileAssignmentDevices_ = new pbc::RepeatedField<long>();
    /// <summary>
    /// Flattened list of device IDs. The order of flattening is the same as used
    /// by IndexUtil::MultiToLinearIndex(tile_assignment_shape).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<long> TileAssignmentDevices {
      get { return tileAssignmentDevices_; }
    }

    /// <summary>Field number for the "tuple_shardings" field.</summary>
    public const int TupleShardingsFieldNumber = 5;
    private static readonly pb::FieldCodec<global::Xla.OpSharding> _repeated_tupleShardings_codec
        = pb::FieldCodec.ForMessage(42, global::Xla.OpSharding.Parser);
    private readonly pbc::RepeatedField<global::Xla.OpSharding> tupleShardings_ = new pbc::RepeatedField<global::Xla.OpSharding>();
    /// <summary>
    /// If type == TUPLE, the sub-shardings, one per leaf node in the tuple shape,
    /// in pre-order. The tuple shape could be nested; here we store just a
    /// flattened list of all leaves in the tuple shape. Note that the tuple shape
    /// is not stored here; shardings do not store the shapes to which they are
    /// applied, this is inferred from the instruction this sharding gets attached
    /// to.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Xla.OpSharding> TupleShardings {
      get { return tupleShardings_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as OpSharding);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(OpSharding other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Type != other.Type) return false;
      if (!object.Equals(TileShape, other.TileShape)) return false;
      if(!tileAssignmentDimensions_.Equals(other.tileAssignmentDimensions_)) return false;
      if(!tileAssignmentDevices_.Equals(other.tileAssignmentDevices_)) return false;
      if(!tupleShardings_.Equals(other.tupleShardings_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Type != 0) hash ^= Type.GetHashCode();
      if (tileShape_ != null) hash ^= TileShape.GetHashCode();
      hash ^= tileAssignmentDimensions_.GetHashCode();
      hash ^= tileAssignmentDevices_.GetHashCode();
      hash ^= tupleShardings_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Type != 0) {
        output.WriteRawTag(8);
        output.WriteEnum((int) Type);
      }
      if (tileShape_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(TileShape);
      }
      tileAssignmentDimensions_.WriteTo(output, _repeated_tileAssignmentDimensions_codec);
      tileAssignmentDevices_.WriteTo(output, _repeated_tileAssignmentDevices_codec);
      tupleShardings_.WriteTo(output, _repeated_tupleShardings_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Type != 0) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Type);
      }
      if (tileShape_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(TileShape);
      }
      size += tileAssignmentDimensions_.CalculateSize(_repeated_tileAssignmentDimensions_codec);
      size += tileAssignmentDevices_.CalculateSize(_repeated_tileAssignmentDevices_codec);
      size += tupleShardings_.CalculateSize(_repeated_tupleShardings_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(OpSharding other) {
      if (other == null) {
        return;
      }
      if (other.Type != 0) {
        Type = other.Type;
      }
      if (other.tileShape_ != null) {
        if (tileShape_ == null) {
          TileShape = new global::Xla.ShapeProto();
        }
        TileShape.MergeFrom(other.TileShape);
      }
      tileAssignmentDimensions_.Add(other.tileAssignmentDimensions_);
      tileAssignmentDevices_.Add(other.tileAssignmentDevices_);
      tupleShardings_.Add(other.tupleShardings_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            Type = (global::Xla.OpSharding.Types.Type) input.ReadEnum();
            break;
          }
          case 18: {
            if (tileShape_ == null) {
              TileShape = new global::Xla.ShapeProto();
            }
            input.ReadMessage(TileShape);
            break;
          }
          case 26:
          case 24: {
            tileAssignmentDimensions_.AddEntriesFrom(input, _repeated_tileAssignmentDimensions_codec);
            break;
          }
          case 34:
          case 32: {
            tileAssignmentDevices_.AddEntriesFrom(input, _repeated_tileAssignmentDevices_codec);
            break;
          }
          case 42: {
            tupleShardings_.AddEntriesFrom(input, _repeated_tupleShardings_codec);
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the OpSharding message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      public enum Type {
        /// <summary>
        /// This sharding is replicated across all devices (implies maximal,
        /// all other fields are unused).
        /// </summary>
        [pbr::OriginalName("REPLICATED")] Replicated = 0,
        /// <summary>
        /// This sharding is maximal - one device runs the entire operation.
        /// </summary>
        [pbr::OriginalName("MAXIMAL")] Maximal = 1,
        /// <summary>
        /// This sharding is a tuple - only the tuple_shardings field is valid.
        /// </summary>
        [pbr::OriginalName("TUPLE")] Tuple = 2,
        /// <summary>
        /// None of the above; tile_shape and tile_assignment are both used.
        /// </summary>
        [pbr::OriginalName("OTHER")] Other = 3,
      }

    }
    #endregion

  }

  /// <summary>
  /// Describes the replica groups in a cross replica op (e.g., all-reduce and
  /// all-to-all).
  /// </summary>
  public sealed partial class ReplicaGroup : pb::IMessage<ReplicaGroup> {
    private static readonly pb::MessageParser<ReplicaGroup> _parser = new pb::MessageParser<ReplicaGroup>(() => new ReplicaGroup());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ReplicaGroup> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Xla.XlaDataReflection.Descriptor.MessageTypes[24]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ReplicaGroup() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ReplicaGroup(ReplicaGroup other) : this() {
      replicaIds_ = other.replicaIds_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ReplicaGroup Clone() {
      return new ReplicaGroup(this);
    }

    /// <summary>Field number for the "replica_ids" field.</summary>
    public const int ReplicaIdsFieldNumber = 1;
    private static readonly pb::FieldCodec<long> _repeated_replicaIds_codec
        = pb::FieldCodec.ForInt64(10);
    private readonly pbc::RepeatedField<long> replicaIds_ = new pbc::RepeatedField<long>();
    /// <summary>
    /// The ids of the replicas that belongs to the same group. The ordering of the
    /// ids matters in some ops (e.g., all-to-all).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<long> ReplicaIds {
      get { return replicaIds_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ReplicaGroup);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ReplicaGroup other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!replicaIds_.Equals(other.replicaIds_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= replicaIds_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      replicaIds_.WriteTo(output, _repeated_replicaIds_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      size += replicaIds_.CalculateSize(_repeated_replicaIds_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ReplicaGroup other) {
      if (other == null) {
        return;
      }
      replicaIds_.Add(other.replicaIds_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10:
          case 8: {
            replicaIds_.AddEntriesFrom(input, _repeated_replicaIds_codec);
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// Describes the source target pair in the collective permute op.
  /// </summary>
  public sealed partial class SourceTarget : pb::IMessage<SourceTarget> {
    private static readonly pb::MessageParser<SourceTarget> _parser = new pb::MessageParser<SourceTarget>(() => new SourceTarget());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<SourceTarget> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Xla.XlaDataReflection.Descriptor.MessageTypes[25]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SourceTarget() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SourceTarget(SourceTarget other) : this() {
      source_ = other.source_;
      target_ = other.target_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SourceTarget Clone() {
      return new SourceTarget(this);
    }

    /// <summary>Field number for the "source" field.</summary>
    public const int SourceFieldNumber = 1;
    private long source_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long Source {
      get { return source_; }
      set {
        source_ = value;
      }
    }

    /// <summary>Field number for the "target" field.</summary>
    public const int TargetFieldNumber = 2;
    private long target_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long Target {
      get { return target_; }
      set {
        target_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as SourceTarget);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(SourceTarget other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Source != other.Source) return false;
      if (Target != other.Target) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Source != 0L) hash ^= Source.GetHashCode();
      if (Target != 0L) hash ^= Target.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Source != 0L) {
        output.WriteRawTag(8);
        output.WriteInt64(Source);
      }
      if (Target != 0L) {
        output.WriteRawTag(16);
        output.WriteInt64(Target);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Source != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(Source);
      }
      if (Target != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(Target);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(SourceTarget other) {
      if (other == null) {
        return;
      }
      if (other.Source != 0L) {
        Source = other.Source;
      }
      if (other.Target != 0L) {
        Target = other.Target;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            Source = input.ReadInt64();
            break;
          }
          case 16: {
            Target = input.ReadInt64();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// Used to indicate the precision configuration. It has backend specific
  /// meaning.
  /// </summary>
  public sealed partial class PrecisionConfig : pb::IMessage<PrecisionConfig> {
    private static readonly pb::MessageParser<PrecisionConfig> _parser = new pb::MessageParser<PrecisionConfig>(() => new PrecisionConfig());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<PrecisionConfig> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Xla.XlaDataReflection.Descriptor.MessageTypes[26]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public PrecisionConfig() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public PrecisionConfig(PrecisionConfig other) : this() {
      operandPrecision_ = other.operandPrecision_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public PrecisionConfig Clone() {
      return new PrecisionConfig(this);
    }

    /// <summary>Field number for the "operand_precision" field.</summary>
    public const int OperandPrecisionFieldNumber = 1;
    private static readonly pb::FieldCodec<global::Xla.PrecisionConfig.Types.Precision> _repeated_operandPrecision_codec
        = pb::FieldCodec.ForEnum(10, x => (int) x, x => (global::Xla.PrecisionConfig.Types.Precision) x);
    private readonly pbc::RepeatedField<global::Xla.PrecisionConfig.Types.Precision> operandPrecision_ = new pbc::RepeatedField<global::Xla.PrecisionConfig.Types.Precision>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Xla.PrecisionConfig.Types.Precision> OperandPrecision {
      get { return operandPrecision_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as PrecisionConfig);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(PrecisionConfig other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!operandPrecision_.Equals(other.operandPrecision_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= operandPrecision_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      operandPrecision_.WriteTo(output, _repeated_operandPrecision_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      size += operandPrecision_.CalculateSize(_repeated_operandPrecision_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(PrecisionConfig other) {
      if (other == null) {
        return;
      }
      operandPrecision_.Add(other.operandPrecision_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10:
          case 8: {
            operandPrecision_.AddEntriesFrom(input, _repeated_operandPrecision_codec);
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the PrecisionConfig message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      public enum Precision {
        [pbr::OriginalName("DEFAULT")] Default = 0,
        [pbr::OriginalName("HIGH")] High = 1,
        [pbr::OriginalName("HIGHEST")] Highest = 2,
      }

    }
    #endregion

  }

  /// <summary>
  /// Describes whether all data-parallelism replicas will receive the same
  /// parameter data at each buffer.
  /// </summary>
  public sealed partial class ParameterReplication : pb::IMessage<ParameterReplication> {
    private static readonly pb::MessageParser<ParameterReplication> _parser = new pb::MessageParser<ParameterReplication>(() => new ParameterReplication());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ParameterReplication> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Xla.XlaDataReflection.Descriptor.MessageTypes[27]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ParameterReplication() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ParameterReplication(ParameterReplication other) : this() {
      replicatedAtLeafBuffers_ = other.replicatedAtLeafBuffers_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ParameterReplication Clone() {
      return new ParameterReplication(this);
    }

    /// <summary>Field number for the "replicated_at_leaf_buffers" field.</summary>
    public const int ReplicatedAtLeafBuffersFieldNumber = 1;
    private static readonly pb::FieldCodec<bool> _repeated_replicatedAtLeafBuffers_codec
        = pb::FieldCodec.ForBool(10);
    private readonly pbc::RepeatedField<bool> replicatedAtLeafBuffers_ = new pbc::RepeatedField<bool>();
    /// <summary>
    /// A list of boolean values for the flattened leaf buffers. Each value
    /// indicates whether the corresponding leaf buffer is replicated.
    ///
    /// If this field is empty, it means no buffer is replicated. Otherwise, the
    /// number of elements in this field must match the number of leaf buffers in
    /// the HLO instruction's shape.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<bool> ReplicatedAtLeafBuffers {
      get { return replicatedAtLeafBuffers_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ParameterReplication);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ParameterReplication other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!replicatedAtLeafBuffers_.Equals(other.replicatedAtLeafBuffers_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= replicatedAtLeafBuffers_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      replicatedAtLeafBuffers_.WriteTo(output, _repeated_replicatedAtLeafBuffers_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      size += replicatedAtLeafBuffers_.CalculateSize(_repeated_replicatedAtLeafBuffers_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ParameterReplication other) {
      if (other == null) {
        return;
      }
      replicatedAtLeafBuffers_.Add(other.replicatedAtLeafBuffers_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10:
          case 8: {
            replicatedAtLeafBuffers_.AddEntriesFrom(input, _repeated_replicatedAtLeafBuffers_codec);
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// A backend-config for kWhile loops that stores the loop's trip count, if it is
  /// known.
  ///
  /// This is useful for backends that can implement a `for i in 0..N` loop more
  /// efficiently than a `while` loop.  For example, on GPUs, we can implement a
  /// `for i in 0..N` loop by enqueueing the kernels for the loop body N times,
  /// whereas implementing a `while` loop requires a host-device sync on each
  /// iteration.
  /// </summary>
  public sealed partial class WhileLoopBackendConfig : pb::IMessage<WhileLoopBackendConfig> {
    private static readonly pb::MessageParser<WhileLoopBackendConfig> _parser = new pb::MessageParser<WhileLoopBackendConfig>(() => new WhileLoopBackendConfig());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<WhileLoopBackendConfig> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Xla.XlaDataReflection.Descriptor.MessageTypes[28]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public WhileLoopBackendConfig() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public WhileLoopBackendConfig(WhileLoopBackendConfig other) : this() {
      knownTripCount_ = other.knownTripCount_ != null ? other.knownTripCount_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public WhileLoopBackendConfig Clone() {
      return new WhileLoopBackendConfig(this);
    }

    /// <summary>Field number for the "known_trip_count" field.</summary>
    public const int KnownTripCountFieldNumber = 1;
    private global::Xla.WhileLoopBackendConfig.Types.KnownTripCount knownTripCount_;
    /// <summary>
    /// This indirection lets us distinguish between known-trip-count == 0 and
    /// unknown-trip-count.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Xla.WhileLoopBackendConfig.Types.KnownTripCount KnownTripCount {
      get { return knownTripCount_; }
      set {
        knownTripCount_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as WhileLoopBackendConfig);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(WhileLoopBackendConfig other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(KnownTripCount, other.KnownTripCount)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (knownTripCount_ != null) hash ^= KnownTripCount.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (knownTripCount_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(KnownTripCount);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (knownTripCount_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(KnownTripCount);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(WhileLoopBackendConfig other) {
      if (other == null) {
        return;
      }
      if (other.knownTripCount_ != null) {
        if (knownTripCount_ == null) {
          KnownTripCount = new global::Xla.WhileLoopBackendConfig.Types.KnownTripCount();
        }
        KnownTripCount.MergeFrom(other.KnownTripCount);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (knownTripCount_ == null) {
              KnownTripCount = new global::Xla.WhileLoopBackendConfig.Types.KnownTripCount();
            }
            input.ReadMessage(KnownTripCount);
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the WhileLoopBackendConfig message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      public sealed partial class KnownTripCount : pb::IMessage<KnownTripCount> {
        private static readonly pb::MessageParser<KnownTripCount> _parser = new pb::MessageParser<KnownTripCount>(() => new KnownTripCount());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<KnownTripCount> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Xla.WhileLoopBackendConfig.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public KnownTripCount() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public KnownTripCount(KnownTripCount other) : this() {
          n_ = other.n_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public KnownTripCount Clone() {
          return new KnownTripCount(this);
        }

        /// <summary>Field number for the "n" field.</summary>
        public const int NFieldNumber = 1;
        private long n_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public long N {
          get { return n_; }
          set {
            n_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as KnownTripCount);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(KnownTripCount other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (N != other.N) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (N != 0L) hash ^= N.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (N != 0L) {
            output.WriteRawTag(8);
            output.WriteInt64(N);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (N != 0L) {
            size += 1 + pb::CodedOutputStream.ComputeInt64Size(N);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(KnownTripCount other) {
          if (other == null) {
            return;
          }
          if (other.N != 0L) {
            N = other.N;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 8: {
                N = input.ReadInt64();
                break;
              }
            }
          }
        }

      }

    }
    #endregion

  }

  #endregion

}

#endregion Designer generated code
