// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: tensorflow/core/protobuf/worker_service.proto
// </auto-generated>
// Original file comments:
// Copyright 2016 The TensorFlow Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ==============================================================================
//
#pragma warning disable 0414, 1591
#region Designer generated code

using grpc = global::Grpc.Core;

namespace Tensorflow.Grpc {
  public static partial class WorkerService
  {
    static readonly string __ServiceName = "tensorflow.grpc.WorkerService";

    static readonly grpc::Marshaller<global::Tensorflow.GetStatusRequest> __Marshaller_tensorflow_GetStatusRequest = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Tensorflow.GetStatusRequest.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Tensorflow.GetStatusResponse> __Marshaller_tensorflow_GetStatusResponse = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Tensorflow.GetStatusResponse.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Tensorflow.CreateWorkerSessionRequest> __Marshaller_tensorflow_CreateWorkerSessionRequest = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Tensorflow.CreateWorkerSessionRequest.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Tensorflow.CreateWorkerSessionResponse> __Marshaller_tensorflow_CreateWorkerSessionResponse = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Tensorflow.CreateWorkerSessionResponse.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Tensorflow.DeleteWorkerSessionRequest> __Marshaller_tensorflow_DeleteWorkerSessionRequest = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Tensorflow.DeleteWorkerSessionRequest.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Tensorflow.DeleteWorkerSessionResponse> __Marshaller_tensorflow_DeleteWorkerSessionResponse = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Tensorflow.DeleteWorkerSessionResponse.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Tensorflow.RegisterGraphRequest> __Marshaller_tensorflow_RegisterGraphRequest = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Tensorflow.RegisterGraphRequest.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Tensorflow.RegisterGraphResponse> __Marshaller_tensorflow_RegisterGraphResponse = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Tensorflow.RegisterGraphResponse.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Tensorflow.DeregisterGraphRequest> __Marshaller_tensorflow_DeregisterGraphRequest = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Tensorflow.DeregisterGraphRequest.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Tensorflow.DeregisterGraphResponse> __Marshaller_tensorflow_DeregisterGraphResponse = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Tensorflow.DeregisterGraphResponse.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Tensorflow.RunGraphRequest> __Marshaller_tensorflow_RunGraphRequest = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Tensorflow.RunGraphRequest.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Tensorflow.RunGraphResponse> __Marshaller_tensorflow_RunGraphResponse = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Tensorflow.RunGraphResponse.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Tensorflow.CleanupGraphRequest> __Marshaller_tensorflow_CleanupGraphRequest = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Tensorflow.CleanupGraphRequest.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Tensorflow.CleanupGraphResponse> __Marshaller_tensorflow_CleanupGraphResponse = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Tensorflow.CleanupGraphResponse.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Tensorflow.CleanupAllRequest> __Marshaller_tensorflow_CleanupAllRequest = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Tensorflow.CleanupAllRequest.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Tensorflow.CleanupAllResponse> __Marshaller_tensorflow_CleanupAllResponse = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Tensorflow.CleanupAllResponse.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Tensorflow.RecvTensorRequest> __Marshaller_tensorflow_RecvTensorRequest = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Tensorflow.RecvTensorRequest.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Tensorflow.RecvTensorResponse> __Marshaller_tensorflow_RecvTensorResponse = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Tensorflow.RecvTensorResponse.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Tensorflow.LoggingRequest> __Marshaller_tensorflow_LoggingRequest = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Tensorflow.LoggingRequest.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Tensorflow.LoggingResponse> __Marshaller_tensorflow_LoggingResponse = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Tensorflow.LoggingResponse.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Tensorflow.TracingRequest> __Marshaller_tensorflow_TracingRequest = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Tensorflow.TracingRequest.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Tensorflow.TracingResponse> __Marshaller_tensorflow_TracingResponse = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Tensorflow.TracingResponse.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Tensorflow.RecvBufRequest> __Marshaller_tensorflow_RecvBufRequest = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Tensorflow.RecvBufRequest.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Tensorflow.RecvBufResponse> __Marshaller_tensorflow_RecvBufResponse = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Tensorflow.RecvBufResponse.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Tensorflow.GetStepSequenceRequest> __Marshaller_tensorflow_GetStepSequenceRequest = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Tensorflow.GetStepSequenceRequest.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Tensorflow.GetStepSequenceResponse> __Marshaller_tensorflow_GetStepSequenceResponse = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Tensorflow.GetStepSequenceResponse.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Tensorflow.CompleteGroupRequest> __Marshaller_tensorflow_CompleteGroupRequest = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Tensorflow.CompleteGroupRequest.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Tensorflow.CompleteGroupResponse> __Marshaller_tensorflow_CompleteGroupResponse = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Tensorflow.CompleteGroupResponse.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Tensorflow.CompleteInstanceRequest> __Marshaller_tensorflow_CompleteInstanceRequest = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Tensorflow.CompleteInstanceRequest.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Tensorflow.CompleteInstanceResponse> __Marshaller_tensorflow_CompleteInstanceResponse = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Tensorflow.CompleteInstanceResponse.Parser.ParseFrom);

    static readonly grpc::Method<global::Tensorflow.GetStatusRequest, global::Tensorflow.GetStatusResponse> __Method_GetStatus = new grpc::Method<global::Tensorflow.GetStatusRequest, global::Tensorflow.GetStatusResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "GetStatus",
        __Marshaller_tensorflow_GetStatusRequest,
        __Marshaller_tensorflow_GetStatusResponse);

    static readonly grpc::Method<global::Tensorflow.CreateWorkerSessionRequest, global::Tensorflow.CreateWorkerSessionResponse> __Method_CreateWorkerSession = new grpc::Method<global::Tensorflow.CreateWorkerSessionRequest, global::Tensorflow.CreateWorkerSessionResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "CreateWorkerSession",
        __Marshaller_tensorflow_CreateWorkerSessionRequest,
        __Marshaller_tensorflow_CreateWorkerSessionResponse);

    static readonly grpc::Method<global::Tensorflow.DeleteWorkerSessionRequest, global::Tensorflow.DeleteWorkerSessionResponse> __Method_DeleteWorkerSession = new grpc::Method<global::Tensorflow.DeleteWorkerSessionRequest, global::Tensorflow.DeleteWorkerSessionResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "DeleteWorkerSession",
        __Marshaller_tensorflow_DeleteWorkerSessionRequest,
        __Marshaller_tensorflow_DeleteWorkerSessionResponse);

    static readonly grpc::Method<global::Tensorflow.RegisterGraphRequest, global::Tensorflow.RegisterGraphResponse> __Method_RegisterGraph = new grpc::Method<global::Tensorflow.RegisterGraphRequest, global::Tensorflow.RegisterGraphResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "RegisterGraph",
        __Marshaller_tensorflow_RegisterGraphRequest,
        __Marshaller_tensorflow_RegisterGraphResponse);

    static readonly grpc::Method<global::Tensorflow.DeregisterGraphRequest, global::Tensorflow.DeregisterGraphResponse> __Method_DeregisterGraph = new grpc::Method<global::Tensorflow.DeregisterGraphRequest, global::Tensorflow.DeregisterGraphResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "DeregisterGraph",
        __Marshaller_tensorflow_DeregisterGraphRequest,
        __Marshaller_tensorflow_DeregisterGraphResponse);

    static readonly grpc::Method<global::Tensorflow.RunGraphRequest, global::Tensorflow.RunGraphResponse> __Method_RunGraph = new grpc::Method<global::Tensorflow.RunGraphRequest, global::Tensorflow.RunGraphResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "RunGraph",
        __Marshaller_tensorflow_RunGraphRequest,
        __Marshaller_tensorflow_RunGraphResponse);

    static readonly grpc::Method<global::Tensorflow.CleanupGraphRequest, global::Tensorflow.CleanupGraphResponse> __Method_CleanupGraph = new grpc::Method<global::Tensorflow.CleanupGraphRequest, global::Tensorflow.CleanupGraphResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "CleanupGraph",
        __Marshaller_tensorflow_CleanupGraphRequest,
        __Marshaller_tensorflow_CleanupGraphResponse);

    static readonly grpc::Method<global::Tensorflow.CleanupAllRequest, global::Tensorflow.CleanupAllResponse> __Method_CleanupAll = new grpc::Method<global::Tensorflow.CleanupAllRequest, global::Tensorflow.CleanupAllResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "CleanupAll",
        __Marshaller_tensorflow_CleanupAllRequest,
        __Marshaller_tensorflow_CleanupAllResponse);

    static readonly grpc::Method<global::Tensorflow.RecvTensorRequest, global::Tensorflow.RecvTensorResponse> __Method_RecvTensor = new grpc::Method<global::Tensorflow.RecvTensorRequest, global::Tensorflow.RecvTensorResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "RecvTensor",
        __Marshaller_tensorflow_RecvTensorRequest,
        __Marshaller_tensorflow_RecvTensorResponse);

    static readonly grpc::Method<global::Tensorflow.LoggingRequest, global::Tensorflow.LoggingResponse> __Method_Logging = new grpc::Method<global::Tensorflow.LoggingRequest, global::Tensorflow.LoggingResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "Logging",
        __Marshaller_tensorflow_LoggingRequest,
        __Marshaller_tensorflow_LoggingResponse);

    static readonly grpc::Method<global::Tensorflow.TracingRequest, global::Tensorflow.TracingResponse> __Method_Tracing = new grpc::Method<global::Tensorflow.TracingRequest, global::Tensorflow.TracingResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "Tracing",
        __Marshaller_tensorflow_TracingRequest,
        __Marshaller_tensorflow_TracingResponse);

    static readonly grpc::Method<global::Tensorflow.RecvBufRequest, global::Tensorflow.RecvBufResponse> __Method_RecvBuf = new grpc::Method<global::Tensorflow.RecvBufRequest, global::Tensorflow.RecvBufResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "RecvBuf",
        __Marshaller_tensorflow_RecvBufRequest,
        __Marshaller_tensorflow_RecvBufResponse);

    static readonly grpc::Method<global::Tensorflow.GetStepSequenceRequest, global::Tensorflow.GetStepSequenceResponse> __Method_GetStepSequence = new grpc::Method<global::Tensorflow.GetStepSequenceRequest, global::Tensorflow.GetStepSequenceResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "GetStepSequence",
        __Marshaller_tensorflow_GetStepSequenceRequest,
        __Marshaller_tensorflow_GetStepSequenceResponse);

    static readonly grpc::Method<global::Tensorflow.CompleteGroupRequest, global::Tensorflow.CompleteGroupResponse> __Method_CompleteGroup = new grpc::Method<global::Tensorflow.CompleteGroupRequest, global::Tensorflow.CompleteGroupResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "CompleteGroup",
        __Marshaller_tensorflow_CompleteGroupRequest,
        __Marshaller_tensorflow_CompleteGroupResponse);

    static readonly grpc::Method<global::Tensorflow.CompleteInstanceRequest, global::Tensorflow.CompleteInstanceResponse> __Method_CompleteInstance = new grpc::Method<global::Tensorflow.CompleteInstanceRequest, global::Tensorflow.CompleteInstanceResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "CompleteInstance",
        __Marshaller_tensorflow_CompleteInstanceRequest,
        __Marshaller_tensorflow_CompleteInstanceResponse);

    /// <summary>Service descriptor</summary>
    public static global::Google.Protobuf.Reflection.ServiceDescriptor Descriptor
    {
      get { return global::Tensorflow.Grpc.WorkerServiceReflection.Descriptor.Services[0]; }
    }

    /// <summary>Client for WorkerService</summary>
    public partial class WorkerServiceClient : grpc::ClientBase<WorkerServiceClient>
    {
      /// <summary>Creates a new client for WorkerService</summary>
      /// <param name="channel">The channel to use to make remote calls.</param>
      public WorkerServiceClient(grpc::ChannelBase channel) : base(channel)
      {
      }
      /// <summary>Creates a new client for WorkerService that uses a custom <c>CallInvoker</c>.</summary>
      /// <param name="callInvoker">The callInvoker to use to make remote calls.</param>
      public WorkerServiceClient(grpc::CallInvoker callInvoker) : base(callInvoker)
      {
      }
      /// <summary>Protected parameterless constructor to allow creation of test doubles.</summary>
      protected WorkerServiceClient() : base()
      {
      }
      /// <summary>Protected constructor to allow creation of configured clients.</summary>
      /// <param name="configuration">The client configuration.</param>
      protected WorkerServiceClient(ClientBaseConfiguration configuration) : base(configuration)
      {
      }

      /// <summary>
      /// See worker.proto for details.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Tensorflow.GetStatusResponse GetStatus(global::Tensorflow.GetStatusRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return GetStatus(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// See worker.proto for details.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Tensorflow.GetStatusResponse GetStatus(global::Tensorflow.GetStatusRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_GetStatus, null, options, request);
      }
      /// <summary>
      /// See worker.proto for details.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Tensorflow.GetStatusResponse> GetStatusAsync(global::Tensorflow.GetStatusRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return GetStatusAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// See worker.proto for details.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Tensorflow.GetStatusResponse> GetStatusAsync(global::Tensorflow.GetStatusRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_GetStatus, null, options, request);
      }
      /// <summary>
      /// See worker.proto for details.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Tensorflow.CreateWorkerSessionResponse CreateWorkerSession(global::Tensorflow.CreateWorkerSessionRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return CreateWorkerSession(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// See worker.proto for details.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Tensorflow.CreateWorkerSessionResponse CreateWorkerSession(global::Tensorflow.CreateWorkerSessionRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_CreateWorkerSession, null, options, request);
      }
      /// <summary>
      /// See worker.proto for details.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Tensorflow.CreateWorkerSessionResponse> CreateWorkerSessionAsync(global::Tensorflow.CreateWorkerSessionRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return CreateWorkerSessionAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// See worker.proto for details.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Tensorflow.CreateWorkerSessionResponse> CreateWorkerSessionAsync(global::Tensorflow.CreateWorkerSessionRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_CreateWorkerSession, null, options, request);
      }
      /// <summary>
      /// See worker.proto for details.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Tensorflow.DeleteWorkerSessionResponse DeleteWorkerSession(global::Tensorflow.DeleteWorkerSessionRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return DeleteWorkerSession(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// See worker.proto for details.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Tensorflow.DeleteWorkerSessionResponse DeleteWorkerSession(global::Tensorflow.DeleteWorkerSessionRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_DeleteWorkerSession, null, options, request);
      }
      /// <summary>
      /// See worker.proto for details.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Tensorflow.DeleteWorkerSessionResponse> DeleteWorkerSessionAsync(global::Tensorflow.DeleteWorkerSessionRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return DeleteWorkerSessionAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// See worker.proto for details.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Tensorflow.DeleteWorkerSessionResponse> DeleteWorkerSessionAsync(global::Tensorflow.DeleteWorkerSessionRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_DeleteWorkerSession, null, options, request);
      }
      /// <summary>
      /// See worker.proto for details.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Tensorflow.RegisterGraphResponse RegisterGraph(global::Tensorflow.RegisterGraphRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return RegisterGraph(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// See worker.proto for details.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Tensorflow.RegisterGraphResponse RegisterGraph(global::Tensorflow.RegisterGraphRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_RegisterGraph, null, options, request);
      }
      /// <summary>
      /// See worker.proto for details.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Tensorflow.RegisterGraphResponse> RegisterGraphAsync(global::Tensorflow.RegisterGraphRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return RegisterGraphAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// See worker.proto for details.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Tensorflow.RegisterGraphResponse> RegisterGraphAsync(global::Tensorflow.RegisterGraphRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_RegisterGraph, null, options, request);
      }
      /// <summary>
      /// See worker.proto for details.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Tensorflow.DeregisterGraphResponse DeregisterGraph(global::Tensorflow.DeregisterGraphRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return DeregisterGraph(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// See worker.proto for details.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Tensorflow.DeregisterGraphResponse DeregisterGraph(global::Tensorflow.DeregisterGraphRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_DeregisterGraph, null, options, request);
      }
      /// <summary>
      /// See worker.proto for details.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Tensorflow.DeregisterGraphResponse> DeregisterGraphAsync(global::Tensorflow.DeregisterGraphRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return DeregisterGraphAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// See worker.proto for details.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Tensorflow.DeregisterGraphResponse> DeregisterGraphAsync(global::Tensorflow.DeregisterGraphRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_DeregisterGraph, null, options, request);
      }
      /// <summary>
      /// See worker.proto for details.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Tensorflow.RunGraphResponse RunGraph(global::Tensorflow.RunGraphRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return RunGraph(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// See worker.proto for details.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Tensorflow.RunGraphResponse RunGraph(global::Tensorflow.RunGraphRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_RunGraph, null, options, request);
      }
      /// <summary>
      /// See worker.proto for details.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Tensorflow.RunGraphResponse> RunGraphAsync(global::Tensorflow.RunGraphRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return RunGraphAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// See worker.proto for details.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Tensorflow.RunGraphResponse> RunGraphAsync(global::Tensorflow.RunGraphRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_RunGraph, null, options, request);
      }
      /// <summary>
      /// See worker.proto for details.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Tensorflow.CleanupGraphResponse CleanupGraph(global::Tensorflow.CleanupGraphRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return CleanupGraph(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// See worker.proto for details.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Tensorflow.CleanupGraphResponse CleanupGraph(global::Tensorflow.CleanupGraphRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_CleanupGraph, null, options, request);
      }
      /// <summary>
      /// See worker.proto for details.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Tensorflow.CleanupGraphResponse> CleanupGraphAsync(global::Tensorflow.CleanupGraphRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return CleanupGraphAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// See worker.proto for details.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Tensorflow.CleanupGraphResponse> CleanupGraphAsync(global::Tensorflow.CleanupGraphRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_CleanupGraph, null, options, request);
      }
      /// <summary>
      /// See worker.proto for details.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Tensorflow.CleanupAllResponse CleanupAll(global::Tensorflow.CleanupAllRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return CleanupAll(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// See worker.proto for details.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Tensorflow.CleanupAllResponse CleanupAll(global::Tensorflow.CleanupAllRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_CleanupAll, null, options, request);
      }
      /// <summary>
      /// See worker.proto for details.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Tensorflow.CleanupAllResponse> CleanupAllAsync(global::Tensorflow.CleanupAllRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return CleanupAllAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// See worker.proto for details.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Tensorflow.CleanupAllResponse> CleanupAllAsync(global::Tensorflow.CleanupAllRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_CleanupAll, null, options, request);
      }
      /// <summary>
      /// See worker.proto for details.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Tensorflow.RecvTensorResponse RecvTensor(global::Tensorflow.RecvTensorRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return RecvTensor(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// See worker.proto for details.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Tensorflow.RecvTensorResponse RecvTensor(global::Tensorflow.RecvTensorRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_RecvTensor, null, options, request);
      }
      /// <summary>
      /// See worker.proto for details.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Tensorflow.RecvTensorResponse> RecvTensorAsync(global::Tensorflow.RecvTensorRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return RecvTensorAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// See worker.proto for details.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Tensorflow.RecvTensorResponse> RecvTensorAsync(global::Tensorflow.RecvTensorRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_RecvTensor, null, options, request);
      }
      /// <summary>
      /// See worker.proto for details.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Tensorflow.LoggingResponse Logging(global::Tensorflow.LoggingRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return Logging(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// See worker.proto for details.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Tensorflow.LoggingResponse Logging(global::Tensorflow.LoggingRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_Logging, null, options, request);
      }
      /// <summary>
      /// See worker.proto for details.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Tensorflow.LoggingResponse> LoggingAsync(global::Tensorflow.LoggingRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return LoggingAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// See worker.proto for details.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Tensorflow.LoggingResponse> LoggingAsync(global::Tensorflow.LoggingRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_Logging, null, options, request);
      }
      /// <summary>
      /// See worker.proto for details.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Tensorflow.TracingResponse Tracing(global::Tensorflow.TracingRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return Tracing(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// See worker.proto for details.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Tensorflow.TracingResponse Tracing(global::Tensorflow.TracingRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_Tracing, null, options, request);
      }
      /// <summary>
      /// See worker.proto for details.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Tensorflow.TracingResponse> TracingAsync(global::Tensorflow.TracingRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return TracingAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// See worker.proto for details.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Tensorflow.TracingResponse> TracingAsync(global::Tensorflow.TracingRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_Tracing, null, options, request);
      }
      /// <summary>
      /// See worker.proto for details.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Tensorflow.RecvBufResponse RecvBuf(global::Tensorflow.RecvBufRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return RecvBuf(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// See worker.proto for details.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Tensorflow.RecvBufResponse RecvBuf(global::Tensorflow.RecvBufRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_RecvBuf, null, options, request);
      }
      /// <summary>
      /// See worker.proto for details.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Tensorflow.RecvBufResponse> RecvBufAsync(global::Tensorflow.RecvBufRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return RecvBufAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// See worker.proto for details.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Tensorflow.RecvBufResponse> RecvBufAsync(global::Tensorflow.RecvBufRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_RecvBuf, null, options, request);
      }
      /// <summary>
      /// See worker.proto for details.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Tensorflow.GetStepSequenceResponse GetStepSequence(global::Tensorflow.GetStepSequenceRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return GetStepSequence(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// See worker.proto for details.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Tensorflow.GetStepSequenceResponse GetStepSequence(global::Tensorflow.GetStepSequenceRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_GetStepSequence, null, options, request);
      }
      /// <summary>
      /// See worker.proto for details.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Tensorflow.GetStepSequenceResponse> GetStepSequenceAsync(global::Tensorflow.GetStepSequenceRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return GetStepSequenceAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// See worker.proto for details.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Tensorflow.GetStepSequenceResponse> GetStepSequenceAsync(global::Tensorflow.GetStepSequenceRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_GetStepSequence, null, options, request);
      }
      /// <summary>
      /// See worker.proto for details.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Tensorflow.CompleteGroupResponse CompleteGroup(global::Tensorflow.CompleteGroupRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return CompleteGroup(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// See worker.proto for details.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Tensorflow.CompleteGroupResponse CompleteGroup(global::Tensorflow.CompleteGroupRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_CompleteGroup, null, options, request);
      }
      /// <summary>
      /// See worker.proto for details.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Tensorflow.CompleteGroupResponse> CompleteGroupAsync(global::Tensorflow.CompleteGroupRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return CompleteGroupAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// See worker.proto for details.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Tensorflow.CompleteGroupResponse> CompleteGroupAsync(global::Tensorflow.CompleteGroupRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_CompleteGroup, null, options, request);
      }
      /// <summary>
      /// See worker.proto for details.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Tensorflow.CompleteInstanceResponse CompleteInstance(global::Tensorflow.CompleteInstanceRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return CompleteInstance(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// See worker.proto for details.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Tensorflow.CompleteInstanceResponse CompleteInstance(global::Tensorflow.CompleteInstanceRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_CompleteInstance, null, options, request);
      }
      /// <summary>
      /// See worker.proto for details.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Tensorflow.CompleteInstanceResponse> CompleteInstanceAsync(global::Tensorflow.CompleteInstanceRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return CompleteInstanceAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// See worker.proto for details.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Tensorflow.CompleteInstanceResponse> CompleteInstanceAsync(global::Tensorflow.CompleteInstanceRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_CompleteInstance, null, options, request);
      }
      /// <summary>Creates a new instance of client from given <c>ClientBaseConfiguration</c>.</summary>
      protected override WorkerServiceClient NewInstance(ClientBaseConfiguration configuration)
      {
        return new WorkerServiceClient(configuration);
      }
    }

  }
}
#endregion
