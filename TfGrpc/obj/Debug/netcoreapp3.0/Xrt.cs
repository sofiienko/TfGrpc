// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: tensorflow/compiler/xrt/xrt.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Xrt {

  /// <summary>Holder for reflection information generated from tensorflow/compiler/xrt/xrt.proto</summary>
  public static partial class XrtReflection {

    #region Descriptor
    /// <summary>File descriptor for tensorflow/compiler/xrt/xrt.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static XrtReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "CiF0ZW5zb3JmbG93L2NvbXBpbGVyL3hydC94cnQucHJvdG8SA3hydBo2dGVu",
            "c29yZmxvdy9jb21waWxlci90ZjJ4bGEvaG9zdF9jb21wdXRlX21ldGFkYXRh",
            "LnByb3RvGil0ZW5zb3JmbG93L2NvbXBpbGVyL3hsYS9zZXJ2aWNlL2hsby5w",
            "cm90bxohdGVuc29yZmxvdy9jb21waWxlci94bGEveGxhLnByb3RvGiZ0ZW5z",
            "b3JmbG93L2NvbXBpbGVyL3hsYS94bGFfZGF0YS5wcm90byLuAQoQRGV2aWNl",
            "QXNzaWdubWVudBJEChNjb21wdXRhdGlvbl9kZXZpY2VzGAEgAygLMicueHJ0",
            "LkRldmljZUFzc2lnbm1lbnQuQ29tcHV0YXRpb25EZXZpY2UakwEKEUNvbXB1",
            "dGF0aW9uRGV2aWNlElYKD3JlcGxpY2FfZGV2aWNlcxgBIAMoCzI9LnhydC5E",
            "ZXZpY2VBc3NpZ25tZW50LkNvbXB1dGF0aW9uRGV2aWNlLkRldmljZU1lc2hD",
            "b29yZGluYXRlcxomChVEZXZpY2VNZXNoQ29vcmRpbmF0ZXMSDQoFdmFsdWUY",
            "ASADKAUirwQKFFhMQUNvbXB1dGF0aW9uQ29uZmlnEhQKDG51bV9yZXBsaWNh",
            "cxgBIAEoBRIdChVudW1fY29yZXNfcGVyX3JlcGxpY2EYAiABKAUSRQoVaG9z",
            "dF9jb21wdXRlX21ldGFkYXRhGAMgASgLMiYudGVuc29yZmxvdy50ZjJ4bGEu",
            "SG9zdENvbXB1dGVNZXRhZGF0YRItCg1wcm9ncmFtX3NoYXBlGAQgASgLMhYu",
            "eGxhLlByb2dyYW1TaGFwZVByb3RvEjYKFnBlcl9jb3JlX3Byb2dyYW1fc2hh",
            "cGUYBSADKAsyFi54bGEuUHJvZ3JhbVNoYXBlUHJvdG8SMAoRZGV2aWNlX2Fz",
            "c2lnbm1lbnQYBiABKAsyFS54cnQuRGV2aWNlQXNzaWdubWVudBIoCg1kZWJ1",
            "Z19vcHRpb25zGAcgASgLMhEueGxhLkRlYnVnT3B0aW9ucxI8CgxleHBlcmlt",
            "ZW50YWwYCCABKAsyJi54cnQuWExBQ29tcHV0YXRpb25Db25maWcuRXhwZXJp",
            "bWVudGFsGpkBCgxFeHBlcmltZW50YWwSVgoWc3RhdGVmdWxfaW5wdXRfaW5k",
            "aWNlcxgBIAMoCzI2LnhydC5YTEFDb21wdXRhdGlvbkNvbmZpZy5FeHBlcmlt",
            "ZW50YWwuVXBkYXRlSW5kZXhQYWlyGjEKD1VwZGF0ZUluZGV4UGFpchINCgVp",
            "bmRleBgBIAEoBRIPCgd1cGRhdGVkGAIgASgIImMKDlhMQUNvbXB1dGF0aW9u",
            "EikKBmNvbmZpZxgBIAEoCzIZLnhydC5YTEFDb21wdXRhdGlvbkNvbmZpZxIm",
            "CgxobG9fc25hcHNob3QYAiABKAsyEC54bGEuSGxvU25hcHNob3QiNwoNWExB",
            "QWxsb2NhdGlvbhIgCgV2YWx1ZRgCIAEoCzIRLnhsYS5MaXRlcmFsUHJvdG9K",
            "BAgBEAIiZAoMWExBVHVwbGVOb2RlEhMKC2lucHV0X2luZGV4GAEgASgFEhwK",
            "FHJlbGVhc2VfaW5wdXRfaGFuZGxlGAIgASgIEiEKBnR1cGxlcxgDIAMoCzIR",
            "LnhydC5YTEFUdXBsZU5vZGUi3wEKElhSVEV4ZWN1dGlvbkNvbmZpZxIWCg5k",
            "ZXZpY2Vfb3JkaW5hbBgBIAEoBRIdChVjb3JlX2luZGV4X2luX3JlcGxpY2EY",
            "AiABKAUSHgoWZXhlY3V0aW9uX2luc3RhbmNlX2tleRgDIAEoCRIQCghybmdf",
            "c2VlZBgEIAEoDRIdChVyZWxlYXNlX2lucHV0X2hhbmRsZXMYBSABKAgSIgoa",
            "cmVsZWFzZV9jb21waWxhdGlvbl9oYW5kbGUYBiABKAgSHQoVcmV0dXJuX2V4",
            "cGxvZGVkX3R1cGxlGAcgASgIImoKF1hSVENoYWluZWRFeGVjdXRlQ29uZmln",
            "EhAKCHJuZ19zZWVkGAEgASgNEh0KFWNvcmVfaW5kZXhfaW5fcmVwbGljYRgC",
            "IAEoBRIeChZleGVjdXRpb25faW5zdGFuY2Vfa2V5GAMgASgJIp8CChNYUlRD",
            "aGFpbmVkRXhlY3V0ZU9wEhUKC2RhdGFfaGFuZGxlGAEgASgDSAASHAoSY29t",
            "cHV0YXRpb25faGFuZGxlGAIgASgDSAASMAoHb3V0cHV0cxgDIAMoCzIfLnhy",
            "dC5YUlRDaGFpbmVkRXhlY3V0ZU9wLk91dHB1dBIuCgZpbnB1dHMYBCADKAsy",
            "Hi54cnQuWFJUQ2hhaW5lZEV4ZWN1dGVPcC5JbnB1dBovCgVJbnB1dBIQCghv",
            "cF9pbmRleBgBIAEoAxIUCgxvdXRwdXRfaW5kZXgYAiABKAMaNAoGT3V0cHV0",
            "EhQKDG91dHB1dF9pbmRleBgBIAEoAxIUCgxyZXN1bHRfaW5kZXgYAiABKANC",
            "CgoIb3Bfb25lb2YiPgoVWFJUQ2hhaW5lZEV4ZWN1dGVQbGFuEiUKA29wcxgB",
            "IAMoCzIYLnhydC5YUlRDaGFpbmVkRXhlY3V0ZU9wYgZwcm90bzM="));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Tensorflow.Tf2Xla.HostComputeMetadataReflection.Descriptor, global::Xla.HloReflection.Descriptor, global::Xla.XlaReflection.Descriptor, global::Xla.XlaDataReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Xrt.DeviceAssignment), global::Xrt.DeviceAssignment.Parser, new[]{ "ComputationDevices" }, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Xrt.DeviceAssignment.Types.ComputationDevice), global::Xrt.DeviceAssignment.Types.ComputationDevice.Parser, new[]{ "ReplicaDevices" }, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Xrt.DeviceAssignment.Types.ComputationDevice.Types.DeviceMeshCoordinates), global::Xrt.DeviceAssignment.Types.ComputationDevice.Types.DeviceMeshCoordinates.Parser, new[]{ "Value" }, null, null, null)})}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Xrt.XLAComputationConfig), global::Xrt.XLAComputationConfig.Parser, new[]{ "NumReplicas", "NumCoresPerReplica", "HostComputeMetadata", "ProgramShape", "PerCoreProgramShape", "DeviceAssignment", "DebugOptions", "Experimental" }, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Xrt.XLAComputationConfig.Types.Experimental), global::Xrt.XLAComputationConfig.Types.Experimental.Parser, new[]{ "StatefulInputIndices" }, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Xrt.XLAComputationConfig.Types.Experimental.Types.UpdateIndexPair), global::Xrt.XLAComputationConfig.Types.Experimental.Types.UpdateIndexPair.Parser, new[]{ "Index", "Updated" }, null, null, null)})}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Xrt.XLAComputation), global::Xrt.XLAComputation.Parser, new[]{ "Config", "HloSnapshot" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Xrt.XLAAllocation), global::Xrt.XLAAllocation.Parser, new[]{ "Value" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Xrt.XLATupleNode), global::Xrt.XLATupleNode.Parser, new[]{ "InputIndex", "ReleaseInputHandle", "Tuples" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Xrt.XRTExecutionConfig), global::Xrt.XRTExecutionConfig.Parser, new[]{ "DeviceOrdinal", "CoreIndexInReplica", "ExecutionInstanceKey", "RngSeed", "ReleaseInputHandles", "ReleaseCompilationHandle", "ReturnExplodedTuple" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Xrt.XRTChainedExecuteConfig), global::Xrt.XRTChainedExecuteConfig.Parser, new[]{ "RngSeed", "CoreIndexInReplica", "ExecutionInstanceKey" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Xrt.XRTChainedExecuteOp), global::Xrt.XRTChainedExecuteOp.Parser, new[]{ "DataHandle", "ComputationHandle", "Outputs", "Inputs" }, new[]{ "OpOneof" }, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Xrt.XRTChainedExecuteOp.Types.Input), global::Xrt.XRTChainedExecuteOp.Types.Input.Parser, new[]{ "OpIndex", "OutputIndex" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Xrt.XRTChainedExecuteOp.Types.Output), global::Xrt.XRTChainedExecuteOp.Types.Output.Parser, new[]{ "OutputIndex", "ResultIndex" }, null, null, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Xrt.XRTChainedExecutePlan), global::Xrt.XRTChainedExecutePlan.Parser, new[]{ "Ops" }, null, null, null)
          }));
    }
    #endregion

  }
  #region Messages
  public sealed partial class DeviceAssignment : pb::IMessage<DeviceAssignment> {
    private static readonly pb::MessageParser<DeviceAssignment> _parser = new pb::MessageParser<DeviceAssignment>(() => new DeviceAssignment());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<DeviceAssignment> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Xrt.XrtReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public DeviceAssignment() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public DeviceAssignment(DeviceAssignment other) : this() {
      computationDevices_ = other.computationDevices_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public DeviceAssignment Clone() {
      return new DeviceAssignment(this);
    }

    /// <summary>Field number for the "computation_devices" field.</summary>
    public const int ComputationDevicesFieldNumber = 1;
    private static readonly pb::FieldCodec<global::Xrt.DeviceAssignment.Types.ComputationDevice> _repeated_computationDevices_codec
        = pb::FieldCodec.ForMessage(10, global::Xrt.DeviceAssignment.Types.ComputationDevice.Parser);
    private readonly pbc::RepeatedField<global::Xrt.DeviceAssignment.Types.ComputationDevice> computationDevices_ = new pbc::RepeatedField<global::Xrt.DeviceAssignment.Types.ComputationDevice>();
    /// <summary>
    /// As many ComputationDevice as many there are computations (number
    /// of cores per replica).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Xrt.DeviceAssignment.Types.ComputationDevice> ComputationDevices {
      get { return computationDevices_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as DeviceAssignment);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(DeviceAssignment other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!computationDevices_.Equals(other.computationDevices_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= computationDevices_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      computationDevices_.WriteTo(output, _repeated_computationDevices_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      size += computationDevices_.CalculateSize(_repeated_computationDevices_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(DeviceAssignment other) {
      if (other == null) {
        return;
      }
      computationDevices_.Add(other.computationDevices_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            computationDevices_.AddEntriesFrom(input, _repeated_computationDevices_codec);
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the DeviceAssignment message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      public sealed partial class ComputationDevice : pb::IMessage<ComputationDevice> {
        private static readonly pb::MessageParser<ComputationDevice> _parser = new pb::MessageParser<ComputationDevice>(() => new ComputationDevice());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<ComputationDevice> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Xrt.DeviceAssignment.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public ComputationDevice() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public ComputationDevice(ComputationDevice other) : this() {
          replicaDevices_ = other.replicaDevices_.Clone();
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public ComputationDevice Clone() {
          return new ComputationDevice(this);
        }

        /// <summary>Field number for the "replica_devices" field.</summary>
        public const int ReplicaDevicesFieldNumber = 1;
        private static readonly pb::FieldCodec<global::Xrt.DeviceAssignment.Types.ComputationDevice.Types.DeviceMeshCoordinates> _repeated_replicaDevices_codec
            = pb::FieldCodec.ForMessage(10, global::Xrt.DeviceAssignment.Types.ComputationDevice.Types.DeviceMeshCoordinates.Parser);
        private readonly pbc::RepeatedField<global::Xrt.DeviceAssignment.Types.ComputationDevice.Types.DeviceMeshCoordinates> replicaDevices_ = new pbc::RepeatedField<global::Xrt.DeviceAssignment.Types.ComputationDevice.Types.DeviceMeshCoordinates>();
        /// <summary>
        /// As many replicas as there are in the replicated computation.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<global::Xrt.DeviceAssignment.Types.ComputationDevice.Types.DeviceMeshCoordinates> ReplicaDevices {
          get { return replicaDevices_; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as ComputationDevice);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(ComputationDevice other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if(!replicaDevices_.Equals(other.replicaDevices_)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          hash ^= replicaDevices_.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          replicaDevices_.WriteTo(output, _repeated_replicaDevices_codec);
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          size += replicaDevices_.CalculateSize(_repeated_replicaDevices_codec);
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(ComputationDevice other) {
          if (other == null) {
            return;
          }
          replicaDevices_.Add(other.replicaDevices_);
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                replicaDevices_.AddEntriesFrom(input, _repeated_replicaDevices_codec);
                break;
              }
            }
          }
        }

        #region Nested types
        /// <summary>Container for nested types declared in the ComputationDevice message type.</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static partial class Types {
          public sealed partial class DeviceMeshCoordinates : pb::IMessage<DeviceMeshCoordinates> {
            private static readonly pb::MessageParser<DeviceMeshCoordinates> _parser = new pb::MessageParser<DeviceMeshCoordinates>(() => new DeviceMeshCoordinates());
            private pb::UnknownFieldSet _unknownFields;
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public static pb::MessageParser<DeviceMeshCoordinates> Parser { get { return _parser; } }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public static pbr::MessageDescriptor Descriptor {
              get { return global::Xrt.DeviceAssignment.Types.ComputationDevice.Descriptor.NestedTypes[0]; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            pbr::MessageDescriptor pb::IMessage.Descriptor {
              get { return Descriptor; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public DeviceMeshCoordinates() {
              OnConstruction();
            }

            partial void OnConstruction();

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public DeviceMeshCoordinates(DeviceMeshCoordinates other) : this() {
              value_ = other.value_.Clone();
              _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public DeviceMeshCoordinates Clone() {
              return new DeviceMeshCoordinates(this);
            }

            /// <summary>Field number for the "value" field.</summary>
            public const int ValueFieldNumber = 1;
            private static readonly pb::FieldCodec<int> _repeated_value_codec
                = pb::FieldCodec.ForInt32(10);
            private readonly pbc::RepeatedField<int> value_ = new pbc::RepeatedField<int>();
            /// <summary>
            /// The mesh coordinates for the device. Usually (X, Y, Core), in the order
            /// in which they are returned in the TopologyProto.
            ///  X    = value(0)
            ///  Y    = value(1)
            ///  Core = value(2)
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public pbc::RepeatedField<int> Value {
              get { return value_; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override bool Equals(object other) {
              return Equals(other as DeviceMeshCoordinates);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public bool Equals(DeviceMeshCoordinates other) {
              if (ReferenceEquals(other, null)) {
                return false;
              }
              if (ReferenceEquals(other, this)) {
                return true;
              }
              if(!value_.Equals(other.value_)) return false;
              return Equals(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override int GetHashCode() {
              int hash = 1;
              hash ^= value_.GetHashCode();
              if (_unknownFields != null) {
                hash ^= _unknownFields.GetHashCode();
              }
              return hash;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override string ToString() {
              return pb::JsonFormatter.ToDiagnosticString(this);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void WriteTo(pb::CodedOutputStream output) {
              value_.WriteTo(output, _repeated_value_codec);
              if (_unknownFields != null) {
                _unknownFields.WriteTo(output);
              }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public int CalculateSize() {
              int size = 0;
              size += value_.CalculateSize(_repeated_value_codec);
              if (_unknownFields != null) {
                size += _unknownFields.CalculateSize();
              }
              return size;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void MergeFrom(DeviceMeshCoordinates other) {
              if (other == null) {
                return;
              }
              value_.Add(other.value_);
              _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void MergeFrom(pb::CodedInputStream input) {
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                    break;
                  case 10:
                  case 8: {
                    value_.AddEntriesFrom(input, _repeated_value_codec);
                    break;
                  }
                }
              }
            }

          }

        }
        #endregion

      }

    }
    #endregion

  }

  /// <summary>
  /// Options for an XLA compilation.
  /// </summary>
  public sealed partial class XLAComputationConfig : pb::IMessage<XLAComputationConfig> {
    private static readonly pb::MessageParser<XLAComputationConfig> _parser = new pb::MessageParser<XLAComputationConfig>(() => new XLAComputationConfig());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<XLAComputationConfig> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Xrt.XrtReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public XLAComputationConfig() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public XLAComputationConfig(XLAComputationConfig other) : this() {
      numReplicas_ = other.numReplicas_;
      numCoresPerReplica_ = other.numCoresPerReplica_;
      hostComputeMetadata_ = other.hostComputeMetadata_ != null ? other.hostComputeMetadata_.Clone() : null;
      programShape_ = other.programShape_ != null ? other.programShape_.Clone() : null;
      perCoreProgramShape_ = other.perCoreProgramShape_.Clone();
      deviceAssignment_ = other.deviceAssignment_ != null ? other.deviceAssignment_.Clone() : null;
      debugOptions_ = other.debugOptions_ != null ? other.debugOptions_.Clone() : null;
      experimental_ = other.experimental_ != null ? other.experimental_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public XLAComputationConfig Clone() {
      return new XLAComputationConfig(this);
    }

    /// <summary>Field number for the "num_replicas" field.</summary>
    public const int NumReplicasFieldNumber = 1;
    private int numReplicas_;
    /// <summary>
    /// The number of replicas the computation will be run on. If this is
    /// default (0) it is interpreted as 1.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int NumReplicas {
      get { return numReplicas_; }
      set {
        numReplicas_ = value;
      }
    }

    /// <summary>Field number for the "num_cores_per_replica" field.</summary>
    public const int NumCoresPerReplicaFieldNumber = 2;
    private int numCoresPerReplica_;
    /// <summary>
    /// The number of "model-parallel" cores per replica. If this is
    /// default (0) it is interpreted as 1.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int NumCoresPerReplica {
      get { return numCoresPerReplica_; }
      set {
        numCoresPerReplica_ = value;
      }
    }

    /// <summary>Field number for the "host_compute_metadata" field.</summary>
    public const int HostComputeMetadataFieldNumber = 3;
    private global::Tensorflow.Tf2Xla.HostComputeMetadata hostComputeMetadata_;
    /// <summary>
    /// Optional metadata about host sends and recvs.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Tensorflow.Tf2Xla.HostComputeMetadata HostComputeMetadata {
      get { return hostComputeMetadata_; }
      set {
        hostComputeMetadata_ = value;
      }
    }

    /// <summary>Field number for the "program_shape" field.</summary>
    public const int ProgramShapeFieldNumber = 4;
    private global::Xla.ProgramShapeProto programShape_;
    /// <summary>
    /// The arg/result shapes for the whole computation.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Xla.ProgramShapeProto ProgramShape {
      get { return programShape_; }
      set {
        programShape_ = value;
      }
    }

    /// <summary>Field number for the "per_core_program_shape" field.</summary>
    public const int PerCoreProgramShapeFieldNumber = 5;
    private static readonly pb::FieldCodec<global::Xla.ProgramShapeProto> _repeated_perCoreProgramShape_codec
        = pb::FieldCodec.ForMessage(42, global::Xla.ProgramShapeProto.Parser);
    private readonly pbc::RepeatedField<global::Xla.ProgramShapeProto> perCoreProgramShape_ = new pbc::RepeatedField<global::Xla.ProgramShapeProto>();
    /// <summary>
    /// The arg/result shapes for each core of a model-parallel
    /// computation. per_core_args_and_result_shapes is optional for a
    /// single-core computation.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Xla.ProgramShapeProto> PerCoreProgramShape {
      get { return perCoreProgramShape_; }
    }

    /// <summary>Field number for the "device_assignment" field.</summary>
    public const int DeviceAssignmentFieldNumber = 6;
    private global::Xrt.DeviceAssignment deviceAssignment_;
    /// <summary>
    /// Describes how replicated computation instances should be assigned to
    /// devices. There are num_cores_per_replica computations, and each one will be
    /// sent and executed to the set of replica device numbers described in the
    /// DeviceAssignment proto.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Xrt.DeviceAssignment DeviceAssignment {
      get { return deviceAssignment_; }
      set {
        deviceAssignment_ = value;
      }
    }

    /// <summary>Field number for the "debug_options" field.</summary>
    public const int DebugOptionsFieldNumber = 7;
    private global::Xla.DebugOptions debugOptions_;
    /// <summary>
    /// The debugging options to be passed to the XLA compilation process.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Xla.DebugOptions DebugOptions {
      get { return debugOptions_; }
      set {
        debugOptions_ = value;
      }
    }

    /// <summary>Field number for the "experimental" field.</summary>
    public const int ExperimentalFieldNumber = 8;
    private global::Xrt.XLAComputationConfig.Types.Experimental experimental_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Xrt.XLAComputationConfig.Types.Experimental Experimental {
      get { return experimental_; }
      set {
        experimental_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as XLAComputationConfig);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(XLAComputationConfig other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (NumReplicas != other.NumReplicas) return false;
      if (NumCoresPerReplica != other.NumCoresPerReplica) return false;
      if (!object.Equals(HostComputeMetadata, other.HostComputeMetadata)) return false;
      if (!object.Equals(ProgramShape, other.ProgramShape)) return false;
      if(!perCoreProgramShape_.Equals(other.perCoreProgramShape_)) return false;
      if (!object.Equals(DeviceAssignment, other.DeviceAssignment)) return false;
      if (!object.Equals(DebugOptions, other.DebugOptions)) return false;
      if (!object.Equals(Experimental, other.Experimental)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (NumReplicas != 0) hash ^= NumReplicas.GetHashCode();
      if (NumCoresPerReplica != 0) hash ^= NumCoresPerReplica.GetHashCode();
      if (hostComputeMetadata_ != null) hash ^= HostComputeMetadata.GetHashCode();
      if (programShape_ != null) hash ^= ProgramShape.GetHashCode();
      hash ^= perCoreProgramShape_.GetHashCode();
      if (deviceAssignment_ != null) hash ^= DeviceAssignment.GetHashCode();
      if (debugOptions_ != null) hash ^= DebugOptions.GetHashCode();
      if (experimental_ != null) hash ^= Experimental.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (NumReplicas != 0) {
        output.WriteRawTag(8);
        output.WriteInt32(NumReplicas);
      }
      if (NumCoresPerReplica != 0) {
        output.WriteRawTag(16);
        output.WriteInt32(NumCoresPerReplica);
      }
      if (hostComputeMetadata_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(HostComputeMetadata);
      }
      if (programShape_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(ProgramShape);
      }
      perCoreProgramShape_.WriteTo(output, _repeated_perCoreProgramShape_codec);
      if (deviceAssignment_ != null) {
        output.WriteRawTag(50);
        output.WriteMessage(DeviceAssignment);
      }
      if (debugOptions_ != null) {
        output.WriteRawTag(58);
        output.WriteMessage(DebugOptions);
      }
      if (experimental_ != null) {
        output.WriteRawTag(66);
        output.WriteMessage(Experimental);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (NumReplicas != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(NumReplicas);
      }
      if (NumCoresPerReplica != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(NumCoresPerReplica);
      }
      if (hostComputeMetadata_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(HostComputeMetadata);
      }
      if (programShape_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ProgramShape);
      }
      size += perCoreProgramShape_.CalculateSize(_repeated_perCoreProgramShape_codec);
      if (deviceAssignment_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(DeviceAssignment);
      }
      if (debugOptions_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(DebugOptions);
      }
      if (experimental_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Experimental);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(XLAComputationConfig other) {
      if (other == null) {
        return;
      }
      if (other.NumReplicas != 0) {
        NumReplicas = other.NumReplicas;
      }
      if (other.NumCoresPerReplica != 0) {
        NumCoresPerReplica = other.NumCoresPerReplica;
      }
      if (other.hostComputeMetadata_ != null) {
        if (hostComputeMetadata_ == null) {
          HostComputeMetadata = new global::Tensorflow.Tf2Xla.HostComputeMetadata();
        }
        HostComputeMetadata.MergeFrom(other.HostComputeMetadata);
      }
      if (other.programShape_ != null) {
        if (programShape_ == null) {
          ProgramShape = new global::Xla.ProgramShapeProto();
        }
        ProgramShape.MergeFrom(other.ProgramShape);
      }
      perCoreProgramShape_.Add(other.perCoreProgramShape_);
      if (other.deviceAssignment_ != null) {
        if (deviceAssignment_ == null) {
          DeviceAssignment = new global::Xrt.DeviceAssignment();
        }
        DeviceAssignment.MergeFrom(other.DeviceAssignment);
      }
      if (other.debugOptions_ != null) {
        if (debugOptions_ == null) {
          DebugOptions = new global::Xla.DebugOptions();
        }
        DebugOptions.MergeFrom(other.DebugOptions);
      }
      if (other.experimental_ != null) {
        if (experimental_ == null) {
          Experimental = new global::Xrt.XLAComputationConfig.Types.Experimental();
        }
        Experimental.MergeFrom(other.Experimental);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            NumReplicas = input.ReadInt32();
            break;
          }
          case 16: {
            NumCoresPerReplica = input.ReadInt32();
            break;
          }
          case 26: {
            if (hostComputeMetadata_ == null) {
              HostComputeMetadata = new global::Tensorflow.Tf2Xla.HostComputeMetadata();
            }
            input.ReadMessage(HostComputeMetadata);
            break;
          }
          case 34: {
            if (programShape_ == null) {
              ProgramShape = new global::Xla.ProgramShapeProto();
            }
            input.ReadMessage(ProgramShape);
            break;
          }
          case 42: {
            perCoreProgramShape_.AddEntriesFrom(input, _repeated_perCoreProgramShape_codec);
            break;
          }
          case 50: {
            if (deviceAssignment_ == null) {
              DeviceAssignment = new global::Xrt.DeviceAssignment();
            }
            input.ReadMessage(DeviceAssignment);
            break;
          }
          case 58: {
            if (debugOptions_ == null) {
              DebugOptions = new global::Xla.DebugOptions();
            }
            input.ReadMessage(DebugOptions);
            break;
          }
          case 66: {
            if (experimental_ == null) {
              Experimental = new global::Xrt.XLAComputationConfig.Types.Experimental();
            }
            input.ReadMessage(Experimental);
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the XLAComputationConfig message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      /// <summary>
      /// Everything inside Experimental is subject to change and is not subject
      /// to API stability guarantees in
      /// https://www.tensorflow.org/guide/version_compat.
      /// </summary>
      public sealed partial class Experimental : pb::IMessage<Experimental> {
        private static readonly pb::MessageParser<Experimental> _parser = new pb::MessageParser<Experimental>(() => new Experimental());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<Experimental> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Xrt.XLAComputationConfig.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Experimental() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Experimental(Experimental other) : this() {
          statefulInputIndices_ = other.statefulInputIndices_.Clone();
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Experimental Clone() {
          return new Experimental(this);
        }

        /// <summary>Field number for the "stateful_input_indices" field.</summary>
        public const int StatefulInputIndicesFieldNumber = 1;
        private static readonly pb::FieldCodec<global::Xrt.XLAComputationConfig.Types.Experimental.Types.UpdateIndexPair> _repeated_statefulInputIndices_codec
            = pb::FieldCodec.ForMessage(10, global::Xrt.XLAComputationConfig.Types.Experimental.Types.UpdateIndexPair.Parser);
        private readonly pbc::RepeatedField<global::Xrt.XLAComputationConfig.Types.Experimental.Types.UpdateIndexPair> statefulInputIndices_ = new pbc::RepeatedField<global::Xrt.XLAComputationConfig.Types.Experimental.Types.UpdateIndexPair>();
        /// <summary>
        /// stateful_input_indices is only useful when using XRT-compiled
        /// programs together with standard TensorFlow TPU execution ops, so should
        /// be ignored by most clients.
        ///
        /// Optionally the client can pass information about which inputs
        /// to the computation are updates to "stateful" quantities. Each
        /// element of stateful_input_indices includes an index indicating
        /// which input argument it corresponds to, and a bool indicating
        /// whether the value is updated or not. If the XRT computation is
        /// going to be used with a TensorFlow TPU execution op then an
        /// input index must be present for each input that will correspond
        /// to a resource variable in the execution op, and may not be
        /// present for any other input.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<global::Xrt.XLAComputationConfig.Types.Experimental.Types.UpdateIndexPair> StatefulInputIndices {
          get { return statefulInputIndices_; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as Experimental);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(Experimental other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if(!statefulInputIndices_.Equals(other.statefulInputIndices_)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          hash ^= statefulInputIndices_.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          statefulInputIndices_.WriteTo(output, _repeated_statefulInputIndices_codec);
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          size += statefulInputIndices_.CalculateSize(_repeated_statefulInputIndices_codec);
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(Experimental other) {
          if (other == null) {
            return;
          }
          statefulInputIndices_.Add(other.statefulInputIndices_);
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                statefulInputIndices_.AddEntriesFrom(input, _repeated_statefulInputIndices_codec);
                break;
              }
            }
          }
        }

        #region Nested types
        /// <summary>Container for nested types declared in the Experimental message type.</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static partial class Types {
          public sealed partial class UpdateIndexPair : pb::IMessage<UpdateIndexPair> {
            private static readonly pb::MessageParser<UpdateIndexPair> _parser = new pb::MessageParser<UpdateIndexPair>(() => new UpdateIndexPair());
            private pb::UnknownFieldSet _unknownFields;
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public static pb::MessageParser<UpdateIndexPair> Parser { get { return _parser; } }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public static pbr::MessageDescriptor Descriptor {
              get { return global::Xrt.XLAComputationConfig.Types.Experimental.Descriptor.NestedTypes[0]; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            pbr::MessageDescriptor pb::IMessage.Descriptor {
              get { return Descriptor; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public UpdateIndexPair() {
              OnConstruction();
            }

            partial void OnConstruction();

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public UpdateIndexPair(UpdateIndexPair other) : this() {
              index_ = other.index_;
              updated_ = other.updated_;
              _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public UpdateIndexPair Clone() {
              return new UpdateIndexPair(this);
            }

            /// <summary>Field number for the "index" field.</summary>
            public const int IndexFieldNumber = 1;
            private int index_;
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public int Index {
              get { return index_; }
              set {
                index_ = value;
              }
            }

            /// <summary>Field number for the "updated" field.</summary>
            public const int UpdatedFieldNumber = 2;
            private bool updated_;
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public bool Updated {
              get { return updated_; }
              set {
                updated_ = value;
              }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override bool Equals(object other) {
              return Equals(other as UpdateIndexPair);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public bool Equals(UpdateIndexPair other) {
              if (ReferenceEquals(other, null)) {
                return false;
              }
              if (ReferenceEquals(other, this)) {
                return true;
              }
              if (Index != other.Index) return false;
              if (Updated != other.Updated) return false;
              return Equals(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override int GetHashCode() {
              int hash = 1;
              if (Index != 0) hash ^= Index.GetHashCode();
              if (Updated != false) hash ^= Updated.GetHashCode();
              if (_unknownFields != null) {
                hash ^= _unknownFields.GetHashCode();
              }
              return hash;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override string ToString() {
              return pb::JsonFormatter.ToDiagnosticString(this);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void WriteTo(pb::CodedOutputStream output) {
              if (Index != 0) {
                output.WriteRawTag(8);
                output.WriteInt32(Index);
              }
              if (Updated != false) {
                output.WriteRawTag(16);
                output.WriteBool(Updated);
              }
              if (_unknownFields != null) {
                _unknownFields.WriteTo(output);
              }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public int CalculateSize() {
              int size = 0;
              if (Index != 0) {
                size += 1 + pb::CodedOutputStream.ComputeInt32Size(Index);
              }
              if (Updated != false) {
                size += 1 + 1;
              }
              if (_unknownFields != null) {
                size += _unknownFields.CalculateSize();
              }
              return size;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void MergeFrom(UpdateIndexPair other) {
              if (other == null) {
                return;
              }
              if (other.Index != 0) {
                Index = other.Index;
              }
              if (other.Updated != false) {
                Updated = other.Updated;
              }
              _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void MergeFrom(pb::CodedInputStream input) {
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                    break;
                  case 8: {
                    Index = input.ReadInt32();
                    break;
                  }
                  case 16: {
                    Updated = input.ReadBool();
                    break;
                  }
                }
              }
            }

          }

        }
        #endregion

      }

    }
    #endregion

  }

  /// <summary>
  /// Options and XLA computation for a compilation.
  /// </summary>
  public sealed partial class XLAComputation : pb::IMessage<XLAComputation> {
    private static readonly pb::MessageParser<XLAComputation> _parser = new pb::MessageParser<XLAComputation>(() => new XLAComputation());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<XLAComputation> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Xrt.XrtReflection.Descriptor.MessageTypes[2]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public XLAComputation() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public XLAComputation(XLAComputation other) : this() {
      config_ = other.config_ != null ? other.config_.Clone() : null;
      hloSnapshot_ = other.hloSnapshot_ != null ? other.hloSnapshot_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public XLAComputation Clone() {
      return new XLAComputation(this);
    }

    /// <summary>Field number for the "config" field.</summary>
    public const int ConfigFieldNumber = 1;
    private global::Xrt.XLAComputationConfig config_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Xrt.XLAComputationConfig Config {
      get { return config_; }
      set {
        config_ = value;
      }
    }

    /// <summary>Field number for the "hlo_snapshot" field.</summary>
    public const int HloSnapshotFieldNumber = 2;
    private global::Xla.HloSnapshot hloSnapshot_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Xla.HloSnapshot HloSnapshot {
      get { return hloSnapshot_; }
      set {
        hloSnapshot_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as XLAComputation);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(XLAComputation other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Config, other.Config)) return false;
      if (!object.Equals(HloSnapshot, other.HloSnapshot)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (config_ != null) hash ^= Config.GetHashCode();
      if (hloSnapshot_ != null) hash ^= HloSnapshot.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (config_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Config);
      }
      if (hloSnapshot_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(HloSnapshot);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (config_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Config);
      }
      if (hloSnapshot_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(HloSnapshot);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(XLAComputation other) {
      if (other == null) {
        return;
      }
      if (other.config_ != null) {
        if (config_ == null) {
          Config = new global::Xrt.XLAComputationConfig();
        }
        Config.MergeFrom(other.Config);
      }
      if (other.hloSnapshot_ != null) {
        if (hloSnapshot_ == null) {
          HloSnapshot = new global::Xla.HloSnapshot();
        }
        HloSnapshot.MergeFrom(other.HloSnapshot);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (config_ == null) {
              Config = new global::Xrt.XLAComputationConfig();
            }
            input.ReadMessage(Config);
            break;
          }
          case 18: {
            if (hloSnapshot_ == null) {
              HloSnapshot = new global::Xla.HloSnapshot();
            }
            input.ReadMessage(HloSnapshot);
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// Literal to allocate space for, and transfer to, device memory.
  /// </summary>
  public sealed partial class XLAAllocation : pb::IMessage<XLAAllocation> {
    private static readonly pb::MessageParser<XLAAllocation> _parser = new pb::MessageParser<XLAAllocation>(() => new XLAAllocation());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<XLAAllocation> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Xrt.XrtReflection.Descriptor.MessageTypes[3]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public XLAAllocation() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public XLAAllocation(XLAAllocation other) : this() {
      value_ = other.value_ != null ? other.value_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public XLAAllocation Clone() {
      return new XLAAllocation(this);
    }

    /// <summary>Field number for the "value" field.</summary>
    public const int ValueFieldNumber = 2;
    private global::Xla.LiteralProto value_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Xla.LiteralProto Value {
      get { return value_; }
      set {
        value_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as XLAAllocation);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(XLAAllocation other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Value, other.Value)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (value_ != null) hash ^= Value.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (value_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Value);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (value_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Value);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(XLAAllocation other) {
      if (other == null) {
        return;
      }
      if (other.value_ != null) {
        if (value_ == null) {
          Value = new global::Xla.LiteralProto();
        }
        Value.MergeFrom(other.Value);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 18: {
            if (value_ == null) {
              Value = new global::Xla.LiteralProto();
            }
            input.ReadMessage(Value);
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// Node in a tree describing a tuple constructed from input handles. A
  /// node is an internal node if tuples is non-empty, in which case
  /// input_index and release_input_handle are ignored. Otherwise a node
  /// is a leaf node. Each leaf XLATupleNode is the index of an input
  /// which corresponds to a handle that will be grafted onto the output
  /// tuple at that location. If release_input_handle is true that input
  /// handle will be released and become invalid.  Inputs may be repeated
  /// in which case leaves of the output tuple will alias. If an input is
  /// repeated, release_input_handle must be false for every leaf where
  /// that input appears.
  ///
  /// For example, if input 0 has shape {} and input 1 has shape {2,3}
  /// then the XLATupleNode with structure {1,{0,1}} corresponds to a
  /// tuple with shape {{2,3},{{},{2,3}}}.
  /// </summary>
  public sealed partial class XLATupleNode : pb::IMessage<XLATupleNode> {
    private static readonly pb::MessageParser<XLATupleNode> _parser = new pb::MessageParser<XLATupleNode>(() => new XLATupleNode());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<XLATupleNode> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Xrt.XrtReflection.Descriptor.MessageTypes[4]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public XLATupleNode() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public XLATupleNode(XLATupleNode other) : this() {
      inputIndex_ = other.inputIndex_;
      releaseInputHandle_ = other.releaseInputHandle_;
      tuples_ = other.tuples_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public XLATupleNode Clone() {
      return new XLATupleNode(this);
    }

    /// <summary>Field number for the "input_index" field.</summary>
    public const int InputIndexFieldNumber = 1;
    private int inputIndex_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int InputIndex {
      get { return inputIndex_; }
      set {
        inputIndex_ = value;
      }
    }

    /// <summary>Field number for the "release_input_handle" field.</summary>
    public const int ReleaseInputHandleFieldNumber = 2;
    private bool releaseInputHandle_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool ReleaseInputHandle {
      get { return releaseInputHandle_; }
      set {
        releaseInputHandle_ = value;
      }
    }

    /// <summary>Field number for the "tuples" field.</summary>
    public const int TuplesFieldNumber = 3;
    private static readonly pb::FieldCodec<global::Xrt.XLATupleNode> _repeated_tuples_codec
        = pb::FieldCodec.ForMessage(26, global::Xrt.XLATupleNode.Parser);
    private readonly pbc::RepeatedField<global::Xrt.XLATupleNode> tuples_ = new pbc::RepeatedField<global::Xrt.XLATupleNode>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Xrt.XLATupleNode> Tuples {
      get { return tuples_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as XLATupleNode);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(XLATupleNode other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (InputIndex != other.InputIndex) return false;
      if (ReleaseInputHandle != other.ReleaseInputHandle) return false;
      if(!tuples_.Equals(other.tuples_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (InputIndex != 0) hash ^= InputIndex.GetHashCode();
      if (ReleaseInputHandle != false) hash ^= ReleaseInputHandle.GetHashCode();
      hash ^= tuples_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (InputIndex != 0) {
        output.WriteRawTag(8);
        output.WriteInt32(InputIndex);
      }
      if (ReleaseInputHandle != false) {
        output.WriteRawTag(16);
        output.WriteBool(ReleaseInputHandle);
      }
      tuples_.WriteTo(output, _repeated_tuples_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (InputIndex != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(InputIndex);
      }
      if (ReleaseInputHandle != false) {
        size += 1 + 1;
      }
      size += tuples_.CalculateSize(_repeated_tuples_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(XLATupleNode other) {
      if (other == null) {
        return;
      }
      if (other.InputIndex != 0) {
        InputIndex = other.InputIndex;
      }
      if (other.ReleaseInputHandle != false) {
        ReleaseInputHandle = other.ReleaseInputHandle;
      }
      tuples_.Add(other.tuples_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            InputIndex = input.ReadInt32();
            break;
          }
          case 16: {
            ReleaseInputHandle = input.ReadBool();
            break;
          }
          case 26: {
            tuples_.AddEntriesFrom(input, _repeated_tuples_codec);
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// Options for an XLA execution.
  /// </summary>
  public sealed partial class XRTExecutionConfig : pb::IMessage<XRTExecutionConfig> {
    private static readonly pb::MessageParser<XRTExecutionConfig> _parser = new pb::MessageParser<XRTExecutionConfig>(() => new XRTExecutionConfig());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<XRTExecutionConfig> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Xrt.XrtReflection.Descriptor.MessageTypes[5]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public XRTExecutionConfig() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public XRTExecutionConfig(XRTExecutionConfig other) : this() {
      deviceOrdinal_ = other.deviceOrdinal_;
      coreIndexInReplica_ = other.coreIndexInReplica_;
      executionInstanceKey_ = other.executionInstanceKey_;
      rngSeed_ = other.rngSeed_;
      releaseInputHandles_ = other.releaseInputHandles_;
      releaseCompilationHandle_ = other.releaseCompilationHandle_;
      returnExplodedTuple_ = other.returnExplodedTuple_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public XRTExecutionConfig Clone() {
      return new XRTExecutionConfig(this);
    }

    /// <summary>Field number for the "device_ordinal" field.</summary>
    public const int DeviceOrdinalFieldNumber = 1;
    private int deviceOrdinal_;
    /// <summary>
    /// Local device to run on. This is present because the execute Op
    /// may be placed on a device such as CPU or TPU_SYSTEM that
    /// logically manages multiple cores.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int DeviceOrdinal {
      get { return deviceOrdinal_; }
      set {
        deviceOrdinal_ = value;
      }
    }

    /// <summary>Field number for the "core_index_in_replica" field.</summary>
    public const int CoreIndexInReplicaFieldNumber = 2;
    private int coreIndexInReplica_;
    /// <summary>
    /// Which model-parallel computation to run from the compiled bundle.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CoreIndexInReplica {
      get { return coreIndexInReplica_; }
      set {
        coreIndexInReplica_ = value;
      }
    }

    /// <summary>Field number for the "execution_instance_key" field.</summary>
    public const int ExecutionInstanceKeyFieldNumber = 3;
    private string executionInstanceKey_ = "";
    /// <summary>
    /// Optional key to disambiguate between executions. This is only
    /// needed if multiple host send/recvs may be outstanding
    /// concurrently with executions.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string ExecutionInstanceKey {
      get { return executionInstanceKey_; }
      set {
        executionInstanceKey_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "rng_seed" field.</summary>
    public const int RngSeedFieldNumber = 4;
    private uint rngSeed_;
    /// <summary>
    /// If non-zero, rng_seed to reset the core with.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint RngSeed {
      get { return rngSeed_; }
      set {
        rngSeed_ = value;
      }
    }

    /// <summary>Field number for the "release_input_handles" field.</summary>
    public const int ReleaseInputHandlesFieldNumber = 5;
    private bool releaseInputHandles_;
    /// <summary>
    /// If true, release allocation handles on the inputs after running.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool ReleaseInputHandles {
      get { return releaseInputHandles_; }
      set {
        releaseInputHandles_ = value;
      }
    }

    /// <summary>Field number for the "release_compilation_handle" field.</summary>
    public const int ReleaseCompilationHandleFieldNumber = 6;
    private bool releaseCompilationHandle_;
    /// <summary>
    /// If true, release the handle to the computation after running.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool ReleaseCompilationHandle {
      get { return releaseCompilationHandle_; }
      set {
        releaseCompilationHandle_ = value;
      }
    }

    /// <summary>Field number for the "return_exploded_tuple" field.</summary>
    public const int ReturnExplodedTupleFieldNumber = 7;
    private bool returnExplodedTuple_;
    /// <summary>
    /// If set to true, and the result shape is a tuple, then instead of returning
    /// a single tuple allocation the execution will return a vector of
    /// allocations, one for each of the first-level elements of the result tuple.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool ReturnExplodedTuple {
      get { return returnExplodedTuple_; }
      set {
        returnExplodedTuple_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as XRTExecutionConfig);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(XRTExecutionConfig other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (DeviceOrdinal != other.DeviceOrdinal) return false;
      if (CoreIndexInReplica != other.CoreIndexInReplica) return false;
      if (ExecutionInstanceKey != other.ExecutionInstanceKey) return false;
      if (RngSeed != other.RngSeed) return false;
      if (ReleaseInputHandles != other.ReleaseInputHandles) return false;
      if (ReleaseCompilationHandle != other.ReleaseCompilationHandle) return false;
      if (ReturnExplodedTuple != other.ReturnExplodedTuple) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (DeviceOrdinal != 0) hash ^= DeviceOrdinal.GetHashCode();
      if (CoreIndexInReplica != 0) hash ^= CoreIndexInReplica.GetHashCode();
      if (ExecutionInstanceKey.Length != 0) hash ^= ExecutionInstanceKey.GetHashCode();
      if (RngSeed != 0) hash ^= RngSeed.GetHashCode();
      if (ReleaseInputHandles != false) hash ^= ReleaseInputHandles.GetHashCode();
      if (ReleaseCompilationHandle != false) hash ^= ReleaseCompilationHandle.GetHashCode();
      if (ReturnExplodedTuple != false) hash ^= ReturnExplodedTuple.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (DeviceOrdinal != 0) {
        output.WriteRawTag(8);
        output.WriteInt32(DeviceOrdinal);
      }
      if (CoreIndexInReplica != 0) {
        output.WriteRawTag(16);
        output.WriteInt32(CoreIndexInReplica);
      }
      if (ExecutionInstanceKey.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(ExecutionInstanceKey);
      }
      if (RngSeed != 0) {
        output.WriteRawTag(32);
        output.WriteUInt32(RngSeed);
      }
      if (ReleaseInputHandles != false) {
        output.WriteRawTag(40);
        output.WriteBool(ReleaseInputHandles);
      }
      if (ReleaseCompilationHandle != false) {
        output.WriteRawTag(48);
        output.WriteBool(ReleaseCompilationHandle);
      }
      if (ReturnExplodedTuple != false) {
        output.WriteRawTag(56);
        output.WriteBool(ReturnExplodedTuple);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (DeviceOrdinal != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(DeviceOrdinal);
      }
      if (CoreIndexInReplica != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(CoreIndexInReplica);
      }
      if (ExecutionInstanceKey.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(ExecutionInstanceKey);
      }
      if (RngSeed != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(RngSeed);
      }
      if (ReleaseInputHandles != false) {
        size += 1 + 1;
      }
      if (ReleaseCompilationHandle != false) {
        size += 1 + 1;
      }
      if (ReturnExplodedTuple != false) {
        size += 1 + 1;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(XRTExecutionConfig other) {
      if (other == null) {
        return;
      }
      if (other.DeviceOrdinal != 0) {
        DeviceOrdinal = other.DeviceOrdinal;
      }
      if (other.CoreIndexInReplica != 0) {
        CoreIndexInReplica = other.CoreIndexInReplica;
      }
      if (other.ExecutionInstanceKey.Length != 0) {
        ExecutionInstanceKey = other.ExecutionInstanceKey;
      }
      if (other.RngSeed != 0) {
        RngSeed = other.RngSeed;
      }
      if (other.ReleaseInputHandles != false) {
        ReleaseInputHandles = other.ReleaseInputHandles;
      }
      if (other.ReleaseCompilationHandle != false) {
        ReleaseCompilationHandle = other.ReleaseCompilationHandle;
      }
      if (other.ReturnExplodedTuple != false) {
        ReturnExplodedTuple = other.ReturnExplodedTuple;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            DeviceOrdinal = input.ReadInt32();
            break;
          }
          case 16: {
            CoreIndexInReplica = input.ReadInt32();
            break;
          }
          case 26: {
            ExecutionInstanceKey = input.ReadString();
            break;
          }
          case 32: {
            RngSeed = input.ReadUInt32();
            break;
          }
          case 40: {
            ReleaseInputHandles = input.ReadBool();
            break;
          }
          case 48: {
            ReleaseCompilationHandle = input.ReadBool();
            break;
          }
          case 56: {
            ReturnExplodedTuple = input.ReadBool();
            break;
          }
        }
      }
    }

  }

  public sealed partial class XRTChainedExecuteConfig : pb::IMessage<XRTChainedExecuteConfig> {
    private static readonly pb::MessageParser<XRTChainedExecuteConfig> _parser = new pb::MessageParser<XRTChainedExecuteConfig>(() => new XRTChainedExecuteConfig());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<XRTChainedExecuteConfig> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Xrt.XrtReflection.Descriptor.MessageTypes[6]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public XRTChainedExecuteConfig() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public XRTChainedExecuteConfig(XRTChainedExecuteConfig other) : this() {
      rngSeed_ = other.rngSeed_;
      coreIndexInReplica_ = other.coreIndexInReplica_;
      executionInstanceKey_ = other.executionInstanceKey_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public XRTChainedExecuteConfig Clone() {
      return new XRTChainedExecuteConfig(this);
    }

    /// <summary>Field number for the "rng_seed" field.</summary>
    public const int RngSeedFieldNumber = 1;
    private uint rngSeed_;
    /// <summary>
    /// If non-zero, rng_seed to reset the core with.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint RngSeed {
      get { return rngSeed_; }
      set {
        rngSeed_ = value;
      }
    }

    /// <summary>Field number for the "core_index_in_replica" field.</summary>
    public const int CoreIndexInReplicaFieldNumber = 2;
    private int coreIndexInReplica_;
    /// <summary>
    /// Which model-parallel computation to run from the compiled bundle.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CoreIndexInReplica {
      get { return coreIndexInReplica_; }
      set {
        coreIndexInReplica_ = value;
      }
    }

    /// <summary>Field number for the "execution_instance_key" field.</summary>
    public const int ExecutionInstanceKeyFieldNumber = 3;
    private string executionInstanceKey_ = "";
    /// <summary>
    /// Optional key to disambiguate between executions. This is only needed if
    /// multiple host send/recvs may be outstanding concurrently with executions.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string ExecutionInstanceKey {
      get { return executionInstanceKey_; }
      set {
        executionInstanceKey_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as XRTChainedExecuteConfig);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(XRTChainedExecuteConfig other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (RngSeed != other.RngSeed) return false;
      if (CoreIndexInReplica != other.CoreIndexInReplica) return false;
      if (ExecutionInstanceKey != other.ExecutionInstanceKey) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (RngSeed != 0) hash ^= RngSeed.GetHashCode();
      if (CoreIndexInReplica != 0) hash ^= CoreIndexInReplica.GetHashCode();
      if (ExecutionInstanceKey.Length != 0) hash ^= ExecutionInstanceKey.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (RngSeed != 0) {
        output.WriteRawTag(8);
        output.WriteUInt32(RngSeed);
      }
      if (CoreIndexInReplica != 0) {
        output.WriteRawTag(16);
        output.WriteInt32(CoreIndexInReplica);
      }
      if (ExecutionInstanceKey.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(ExecutionInstanceKey);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (RngSeed != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(RngSeed);
      }
      if (CoreIndexInReplica != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(CoreIndexInReplica);
      }
      if (ExecutionInstanceKey.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(ExecutionInstanceKey);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(XRTChainedExecuteConfig other) {
      if (other == null) {
        return;
      }
      if (other.RngSeed != 0) {
        RngSeed = other.RngSeed;
      }
      if (other.CoreIndexInReplica != 0) {
        CoreIndexInReplica = other.CoreIndexInReplica;
      }
      if (other.ExecutionInstanceKey.Length != 0) {
        ExecutionInstanceKey = other.ExecutionInstanceKey;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            RngSeed = input.ReadUInt32();
            break;
          }
          case 16: {
            CoreIndexInReplica = input.ReadInt32();
            break;
          }
          case 26: {
            ExecutionInstanceKey = input.ReadString();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// A single chained execute operation. An operation can either be a device data
  /// load, or an existing (as in, previously compiled and accessible via its int64
  /// handle) XLA computation execution.
  /// </summary>
  public sealed partial class XRTChainedExecuteOp : pb::IMessage<XRTChainedExecuteOp> {
    private static readonly pb::MessageParser<XRTChainedExecuteOp> _parser = new pb::MessageParser<XRTChainedExecuteOp>(() => new XRTChainedExecuteOp());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<XRTChainedExecuteOp> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Xrt.XrtReflection.Descriptor.MessageTypes[7]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public XRTChainedExecuteOp() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public XRTChainedExecuteOp(XRTChainedExecuteOp other) : this() {
      outputs_ = other.outputs_.Clone();
      inputs_ = other.inputs_.Clone();
      switch (other.OpOneofCase) {
        case OpOneofOneofCase.DataHandle:
          DataHandle = other.DataHandle;
          break;
        case OpOneofOneofCase.ComputationHandle:
          ComputationHandle = other.ComputationHandle;
          break;
      }

      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public XRTChainedExecuteOp Clone() {
      return new XRTChainedExecuteOp(this);
    }

    /// <summary>Field number for the "data_handle" field.</summary>
    public const int DataHandleFieldNumber = 1;
    /// <summary>
    /// The handle to an existing XRT device data.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long DataHandle {
      get { return opOneofCase_ == OpOneofOneofCase.DataHandle ? (long) opOneof_ : 0L; }
      set {
        opOneof_ = value;
        opOneofCase_ = OpOneofOneofCase.DataHandle;
      }
    }

    /// <summary>Field number for the "computation_handle" field.</summary>
    public const int ComputationHandleFieldNumber = 2;
    /// <summary>
    /// The handle to an existing XRT compiled computation.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long ComputationHandle {
      get { return opOneofCase_ == OpOneofOneofCase.ComputationHandle ? (long) opOneof_ : 0L; }
      set {
        opOneof_ = value;
        opOneofCase_ = OpOneofOneofCase.ComputationHandle;
      }
    }

    /// <summary>Field number for the "outputs" field.</summary>
    public const int OutputsFieldNumber = 3;
    private static readonly pb::FieldCodec<global::Xrt.XRTChainedExecuteOp.Types.Output> _repeated_outputs_codec
        = pb::FieldCodec.ForMessage(26, global::Xrt.XRTChainedExecuteOp.Types.Output.Parser);
    private readonly pbc::RepeatedField<global::Xrt.XRTChainedExecuteOp.Types.Output> outputs_ = new pbc::RepeatedField<global::Xrt.XRTChainedExecuteOp.Types.Output>();
    /// <summary>
    /// The outputs of this XRTChainedExecuteOp operation.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Xrt.XRTChainedExecuteOp.Types.Output> Outputs {
      get { return outputs_; }
    }

    /// <summary>Field number for the "inputs" field.</summary>
    public const int InputsFieldNumber = 4;
    private static readonly pb::FieldCodec<global::Xrt.XRTChainedExecuteOp.Types.Input> _repeated_inputs_codec
        = pb::FieldCodec.ForMessage(34, global::Xrt.XRTChainedExecuteOp.Types.Input.Parser);
    private readonly pbc::RepeatedField<global::Xrt.XRTChainedExecuteOp.Types.Input> inputs_ = new pbc::RepeatedField<global::Xrt.XRTChainedExecuteOp.Types.Input>();
    /// <summary>
    /// The inputs of this XRTChainedExecuteOp operation. If data_handle is set,
    /// there are no inputs.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Xrt.XRTChainedExecuteOp.Types.Input> Inputs {
      get { return inputs_; }
    }

    private object opOneof_;
    /// <summary>Enum of possible cases for the "op_oneof" oneof.</summary>
    public enum OpOneofOneofCase {
      None = 0,
      DataHandle = 1,
      ComputationHandle = 2,
    }
    private OpOneofOneofCase opOneofCase_ = OpOneofOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public OpOneofOneofCase OpOneofCase {
      get { return opOneofCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearOpOneof() {
      opOneofCase_ = OpOneofOneofCase.None;
      opOneof_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as XRTChainedExecuteOp);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(XRTChainedExecuteOp other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (DataHandle != other.DataHandle) return false;
      if (ComputationHandle != other.ComputationHandle) return false;
      if(!outputs_.Equals(other.outputs_)) return false;
      if(!inputs_.Equals(other.inputs_)) return false;
      if (OpOneofCase != other.OpOneofCase) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (opOneofCase_ == OpOneofOneofCase.DataHandle) hash ^= DataHandle.GetHashCode();
      if (opOneofCase_ == OpOneofOneofCase.ComputationHandle) hash ^= ComputationHandle.GetHashCode();
      hash ^= outputs_.GetHashCode();
      hash ^= inputs_.GetHashCode();
      hash ^= (int) opOneofCase_;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (opOneofCase_ == OpOneofOneofCase.DataHandle) {
        output.WriteRawTag(8);
        output.WriteInt64(DataHandle);
      }
      if (opOneofCase_ == OpOneofOneofCase.ComputationHandle) {
        output.WriteRawTag(16);
        output.WriteInt64(ComputationHandle);
      }
      outputs_.WriteTo(output, _repeated_outputs_codec);
      inputs_.WriteTo(output, _repeated_inputs_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (opOneofCase_ == OpOneofOneofCase.DataHandle) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(DataHandle);
      }
      if (opOneofCase_ == OpOneofOneofCase.ComputationHandle) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(ComputationHandle);
      }
      size += outputs_.CalculateSize(_repeated_outputs_codec);
      size += inputs_.CalculateSize(_repeated_inputs_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(XRTChainedExecuteOp other) {
      if (other == null) {
        return;
      }
      outputs_.Add(other.outputs_);
      inputs_.Add(other.inputs_);
      switch (other.OpOneofCase) {
        case OpOneofOneofCase.DataHandle:
          DataHandle = other.DataHandle;
          break;
        case OpOneofOneofCase.ComputationHandle:
          ComputationHandle = other.ComputationHandle;
          break;
      }

      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            DataHandle = input.ReadInt64();
            break;
          }
          case 16: {
            ComputationHandle = input.ReadInt64();
            break;
          }
          case 26: {
            outputs_.AddEntriesFrom(input, _repeated_outputs_codec);
            break;
          }
          case 34: {
            inputs_.AddEntriesFrom(input, _repeated_inputs_codec);
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the XRTChainedExecuteOp message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      /// <summary>
      /// Represents an input for this operation.
      /// </summary>
      public sealed partial class Input : pb::IMessage<Input> {
        private static readonly pb::MessageParser<Input> _parser = new pb::MessageParser<Input>(() => new Input());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<Input> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Xrt.XRTChainedExecuteOp.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Input() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Input(Input other) : this() {
          opIndex_ = other.opIndex_;
          outputIndex_ = other.outputIndex_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Input Clone() {
          return new Input(this);
        }

        /// <summary>Field number for the "op_index" field.</summary>
        public const int OpIndexFieldNumber = 1;
        private long opIndex_;
        /// <summary>
        /// The index within the XRTChainedExecutePlan.ops post-order of the source
        /// operation for this input.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public long OpIndex {
          get { return opIndex_; }
          set {
            opIndex_ = value;
          }
        }

        /// <summary>Field number for the "output_index" field.</summary>
        public const int OutputIndexFieldNumber = 2;
        private long outputIndex_;
        /// <summary>
        /// The output index of the value generated by the operation at op_index.
        /// Zero (default value) means no index ({}) while if an indexing is
        /// required, output_index needs to be set to index+1.
        /// Thanks proto3!
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public long OutputIndex {
          get { return outputIndex_; }
          set {
            outputIndex_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as Input);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(Input other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (OpIndex != other.OpIndex) return false;
          if (OutputIndex != other.OutputIndex) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (OpIndex != 0L) hash ^= OpIndex.GetHashCode();
          if (OutputIndex != 0L) hash ^= OutputIndex.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (OpIndex != 0L) {
            output.WriteRawTag(8);
            output.WriteInt64(OpIndex);
          }
          if (OutputIndex != 0L) {
            output.WriteRawTag(16);
            output.WriteInt64(OutputIndex);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (OpIndex != 0L) {
            size += 1 + pb::CodedOutputStream.ComputeInt64Size(OpIndex);
          }
          if (OutputIndex != 0L) {
            size += 1 + pb::CodedOutputStream.ComputeInt64Size(OutputIndex);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(Input other) {
          if (other == null) {
            return;
          }
          if (other.OpIndex != 0L) {
            OpIndex = other.OpIndex;
          }
          if (other.OutputIndex != 0L) {
            OutputIndex = other.OutputIndex;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 8: {
                OpIndex = input.ReadInt64();
                break;
              }
              case 16: {
                OutputIndex = input.ReadInt64();
                break;
              }
            }
          }
        }

      }

      /// <summary>
      /// Represents an output of the XRTChainedExecute operation, which should
      /// originate by the output of this operation.
      /// </summary>
      public sealed partial class Output : pb::IMessage<Output> {
        private static readonly pb::MessageParser<Output> _parser = new pb::MessageParser<Output>(() => new Output());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<Output> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Xrt.XRTChainedExecuteOp.Descriptor.NestedTypes[1]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Output() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Output(Output other) : this() {
          outputIndex_ = other.outputIndex_;
          resultIndex_ = other.resultIndex_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Output Clone() {
          return new Output(this);
        }

        /// <summary>Field number for the "output_index" field.</summary>
        public const int OutputIndexFieldNumber = 1;
        private long outputIndex_;
        /// <summary>
        /// The index in the value generated by this operation, which should be
        /// forwarded as XRTChainedExecute output. If output_index is zero (default
        /// value) the whole output will be used as result. This means that if the
        /// output shape is a tuple, the result will be the full tuple. Otherwise the
        /// real sub-tuple index will be output_index - 1.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public long OutputIndex {
          get { return outputIndex_; }
          set {
            outputIndex_ = value;
          }
        }

        /// <summary>Field number for the "result_index" field.</summary>
        public const int ResultIndexFieldNumber = 2;
        private long resultIndex_;
        /// <summary>
        /// The index in the vector of the results returned by the XRTChainedExecute
        /// operation, where this output should be forwarded.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public long ResultIndex {
          get { return resultIndex_; }
          set {
            resultIndex_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as Output);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(Output other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (OutputIndex != other.OutputIndex) return false;
          if (ResultIndex != other.ResultIndex) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (OutputIndex != 0L) hash ^= OutputIndex.GetHashCode();
          if (ResultIndex != 0L) hash ^= ResultIndex.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (OutputIndex != 0L) {
            output.WriteRawTag(8);
            output.WriteInt64(OutputIndex);
          }
          if (ResultIndex != 0L) {
            output.WriteRawTag(16);
            output.WriteInt64(ResultIndex);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (OutputIndex != 0L) {
            size += 1 + pb::CodedOutputStream.ComputeInt64Size(OutputIndex);
          }
          if (ResultIndex != 0L) {
            size += 1 + pb::CodedOutputStream.ComputeInt64Size(ResultIndex);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(Output other) {
          if (other == null) {
            return;
          }
          if (other.OutputIndex != 0L) {
            OutputIndex = other.OutputIndex;
          }
          if (other.ResultIndex != 0L) {
            ResultIndex = other.ResultIndex;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 8: {
                OutputIndex = input.ReadInt64();
                break;
              }
              case 16: {
                ResultIndex = input.ReadInt64();
                break;
              }
            }
          }
        }

      }

    }
    #endregion

  }

  /// <summary>
  /// Execution plan for the XRTChainedExecute operation.
  /// </summary>
  public sealed partial class XRTChainedExecutePlan : pb::IMessage<XRTChainedExecutePlan> {
    private static readonly pb::MessageParser<XRTChainedExecutePlan> _parser = new pb::MessageParser<XRTChainedExecutePlan>(() => new XRTChainedExecutePlan());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<XRTChainedExecutePlan> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Xrt.XrtReflection.Descriptor.MessageTypes[8]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public XRTChainedExecutePlan() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public XRTChainedExecutePlan(XRTChainedExecutePlan other) : this() {
      ops_ = other.ops_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public XRTChainedExecutePlan Clone() {
      return new XRTChainedExecutePlan(this);
    }

    /// <summary>Field number for the "ops" field.</summary>
    public const int OpsFieldNumber = 1;
    private static readonly pb::FieldCodec<global::Xrt.XRTChainedExecuteOp> _repeated_ops_codec
        = pb::FieldCodec.ForMessage(10, global::Xrt.XRTChainedExecuteOp.Parser);
    private readonly pbc::RepeatedField<global::Xrt.XRTChainedExecuteOp> ops_ = new pbc::RepeatedField<global::Xrt.XRTChainedExecuteOp>();
    /// <summary>
    /// The post order with the XRT computations to be executed.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Xrt.XRTChainedExecuteOp> Ops {
      get { return ops_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as XRTChainedExecutePlan);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(XRTChainedExecutePlan other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!ops_.Equals(other.ops_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= ops_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      ops_.WriteTo(output, _repeated_ops_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      size += ops_.CalculateSize(_repeated_ops_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(XRTChainedExecutePlan other) {
      if (other == null) {
        return;
      }
      ops_.Add(other.ops_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            ops_.AddEntriesFrom(input, _repeated_ops_codec);
            break;
          }
        }
      }
    }

  }

  #endregion

}

#endregion Designer generated code
