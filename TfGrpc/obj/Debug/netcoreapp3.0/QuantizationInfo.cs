// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: tensorflow/compiler/mlir/lite/quantization/quantization_info.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Mlir.Quant {

  /// <summary>Holder for reflection information generated from tensorflow/compiler/mlir/lite/quantization/quantization_info.proto</summary>
  public static partial class QuantizationInfoReflection {

    #region Descriptor
    /// <summary>File descriptor for tensorflow/compiler/mlir/lite/quantization/quantization_info.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static QuantizationInfoReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "CkJ0ZW5zb3JmbG93L2NvbXBpbGVyL21saXIvbGl0ZS9xdWFudGl6YXRpb24v",
            "cXVhbnRpemF0aW9uX2luZm8ucHJvdG8SCm1saXIucXVhbnQi0gQKEFF1YW50",
            "aXphdGlvbkluZm8SOQoHZW50cmllcxgBIAMoCzIoLm1saXIucXVhbnQuUXVh",
            "bnRpemF0aW9uSW5mby5RdWFudFBhcmFtcxoiCgZNaW5NYXgSCwoDbWluGAEg",
            "ASgCEgsKA21heBgCIAEoAhoxCgxBZmZpbmVQYXJhbXMSDQoFc2NhbGUYASAB",
            "KAISEgoKemVyb19wb2ludBgCIAEoBRqbAQoNUGVyQXhpc1BhcmFtcxI2Cgdt",
            "aW5fbWF4GAEgASgLMiMubWxpci5xdWFudC5RdWFudGl6YXRpb25JbmZvLk1p",
            "bk1heEgAEkIKDWFmZmluZV9wYXJhbXMYAiABKAsyKS5tbGlyLnF1YW50LlF1",
            "YW50aXphdGlvbkluZm8uQWZmaW5lUGFyYW1zSABCDgoMcGFyYW1zX29uZW9m",
            "GlkKCE1ldGFkYXRhEhAKCG51bV9iaXRzGAEgASgFEhUKDXF1YW50aXplX2F4",
            "aXMYAiABKAUSEQoJcmFuZ2VfbWluGAMgASgFEhEKCXJhbmdlX21heBgEIAEo",
            "BRqyAQoLUXVhbnRQYXJhbXMSDgoEbmFtZRgBIAEoCUgAEhQKCm5hbWVfcmVn",
            "ZXgYAiABKAlIABI6CgZwYXJhbXMYAyADKAsyKi5tbGlyLnF1YW50LlF1YW50",
            "aXphdGlvbkluZm8uUGVyQXhpc1BhcmFtcxIzCgRtZXRhGAUgASgLMiUubWxp",
            "ci5xdWFudC5RdWFudGl6YXRpb25JbmZvLk1ldGFkYXRhQgwKCm5hbWVfb25l",
            "b2ZCA/gBAWIGcHJvdG8z"));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { },
          new pbr::GeneratedClrTypeInfo(null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Mlir.Quant.QuantizationInfo), global::Mlir.Quant.QuantizationInfo.Parser, new[]{ "Entries" }, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Mlir.Quant.QuantizationInfo.Types.MinMax), global::Mlir.Quant.QuantizationInfo.Types.MinMax.Parser, new[]{ "Min", "Max" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Mlir.Quant.QuantizationInfo.Types.AffineParams), global::Mlir.Quant.QuantizationInfo.Types.AffineParams.Parser, new[]{ "Scale", "ZeroPoint" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Mlir.Quant.QuantizationInfo.Types.PerAxisParams), global::Mlir.Quant.QuantizationInfo.Types.PerAxisParams.Parser, new[]{ "MinMax", "AffineParams" }, new[]{ "ParamsOneof" }, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Mlir.Quant.QuantizationInfo.Types.Metadata), global::Mlir.Quant.QuantizationInfo.Types.Metadata.Parser, new[]{ "NumBits", "QuantizeAxis", "RangeMin", "RangeMax" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Mlir.Quant.QuantizationInfo.Types.QuantParams), global::Mlir.Quant.QuantizationInfo.Types.QuantParams.Parser, new[]{ "Name", "NameRegex", "Params", "Meta" }, new[]{ "NameOneof" }, null, null)})
          }));
    }
    #endregion

  }
  #region Messages
  /// <summary>
  /// Represents the quantization parameters for a list of named tensors.
  /// </summary>
  public sealed partial class QuantizationInfo : pb::IMessage<QuantizationInfo> {
    private static readonly pb::MessageParser<QuantizationInfo> _parser = new pb::MessageParser<QuantizationInfo>(() => new QuantizationInfo());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<QuantizationInfo> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Mlir.Quant.QuantizationInfoReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public QuantizationInfo() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public QuantizationInfo(QuantizationInfo other) : this() {
      entries_ = other.entries_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public QuantizationInfo Clone() {
      return new QuantizationInfo(this);
    }

    /// <summary>Field number for the "entries" field.</summary>
    public const int EntriesFieldNumber = 1;
    private static readonly pb::FieldCodec<global::Mlir.Quant.QuantizationInfo.Types.QuantParams> _repeated_entries_codec
        = pb::FieldCodec.ForMessage(10, global::Mlir.Quant.QuantizationInfo.Types.QuantParams.Parser);
    private readonly pbc::RepeatedField<global::Mlir.Quant.QuantizationInfo.Types.QuantParams> entries_ = new pbc::RepeatedField<global::Mlir.Quant.QuantizationInfo.Types.QuantParams>();
    /// <summary>
    /// List of quantization parameters for tensors.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Mlir.Quant.QuantizationInfo.Types.QuantParams> Entries {
      get { return entries_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as QuantizationInfo);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(QuantizationInfo other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!entries_.Equals(other.entries_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= entries_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      entries_.WriteTo(output, _repeated_entries_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      size += entries_.CalculateSize(_repeated_entries_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(QuantizationInfo other) {
      if (other == null) {
        return;
      }
      entries_.Add(other.entries_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            entries_.AddEntriesFrom(input, _repeated_entries_codec);
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the QuantizationInfo message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      /// <summary>
      /// min/max of the per axis value range. To quantize the value, the metadata
      /// of the target properties should be specified or read from the ops
      /// quantization specification.
      /// </summary>
      public sealed partial class MinMax : pb::IMessage<MinMax> {
        private static readonly pb::MessageParser<MinMax> _parser = new pb::MessageParser<MinMax>(() => new MinMax());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<MinMax> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Mlir.Quant.QuantizationInfo.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public MinMax() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public MinMax(MinMax other) : this() {
          min_ = other.min_;
          max_ = other.max_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public MinMax Clone() {
          return new MinMax(this);
        }

        /// <summary>Field number for the "min" field.</summary>
        public const int MinFieldNumber = 1;
        private float min_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public float Min {
          get { return min_; }
          set {
            min_ = value;
          }
        }

        /// <summary>Field number for the "max" field.</summary>
        public const int MaxFieldNumber = 2;
        private float max_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public float Max {
          get { return max_; }
          set {
            max_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as MinMax);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(MinMax other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(Min, other.Min)) return false;
          if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(Max, other.Max)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (Min != 0F) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(Min);
          if (Max != 0F) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(Max);
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (Min != 0F) {
            output.WriteRawTag(13);
            output.WriteFloat(Min);
          }
          if (Max != 0F) {
            output.WriteRawTag(21);
            output.WriteFloat(Max);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (Min != 0F) {
            size += 1 + 4;
          }
          if (Max != 0F) {
            size += 1 + 4;
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(MinMax other) {
          if (other == null) {
            return;
          }
          if (other.Min != 0F) {
            Min = other.Min;
          }
          if (other.Max != 0F) {
            Max = other.Max;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 13: {
                Min = input.ReadFloat();
                break;
              }
              case 21: {
                Max = input.ReadFloat();
                break;
              }
            }
          }
        }

      }

      /// <summary>
      /// Affine parameters to quantize the per axis value. The metadata of the
      /// target properties should be specified as well.
      /// </summary>
      public sealed partial class AffineParams : pb::IMessage<AffineParams> {
        private static readonly pb::MessageParser<AffineParams> _parser = new pb::MessageParser<AffineParams>(() => new AffineParams());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<AffineParams> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Mlir.Quant.QuantizationInfo.Descriptor.NestedTypes[1]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public AffineParams() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public AffineParams(AffineParams other) : this() {
          scale_ = other.scale_;
          zeroPoint_ = other.zeroPoint_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public AffineParams Clone() {
          return new AffineParams(this);
        }

        /// <summary>Field number for the "scale" field.</summary>
        public const int ScaleFieldNumber = 1;
        private float scale_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public float Scale {
          get { return scale_; }
          set {
            scale_ = value;
          }
        }

        /// <summary>Field number for the "zero_point" field.</summary>
        public const int ZeroPointFieldNumber = 2;
        private int zeroPoint_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int ZeroPoint {
          get { return zeroPoint_; }
          set {
            zeroPoint_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as AffineParams);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(AffineParams other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(Scale, other.Scale)) return false;
          if (ZeroPoint != other.ZeroPoint) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (Scale != 0F) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(Scale);
          if (ZeroPoint != 0) hash ^= ZeroPoint.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (Scale != 0F) {
            output.WriteRawTag(13);
            output.WriteFloat(Scale);
          }
          if (ZeroPoint != 0) {
            output.WriteRawTag(16);
            output.WriteInt32(ZeroPoint);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (Scale != 0F) {
            size += 1 + 4;
          }
          if (ZeroPoint != 0) {
            size += 1 + pb::CodedOutputStream.ComputeInt32Size(ZeroPoint);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(AffineParams other) {
          if (other == null) {
            return;
          }
          if (other.Scale != 0F) {
            Scale = other.Scale;
          }
          if (other.ZeroPoint != 0) {
            ZeroPoint = other.ZeroPoint;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 13: {
                Scale = input.ReadFloat();
                break;
              }
              case 16: {
                ZeroPoint = input.ReadInt32();
                break;
              }
            }
          }
        }

      }

      /// <summary>
      /// Params to quantize the axis. Only one of the field can be used.
      /// </summary>
      public sealed partial class PerAxisParams : pb::IMessage<PerAxisParams> {
        private static readonly pb::MessageParser<PerAxisParams> _parser = new pb::MessageParser<PerAxisParams>(() => new PerAxisParams());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<PerAxisParams> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Mlir.Quant.QuantizationInfo.Descriptor.NestedTypes[2]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public PerAxisParams() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public PerAxisParams(PerAxisParams other) : this() {
          switch (other.ParamsOneofCase) {
            case ParamsOneofOneofCase.MinMax:
              MinMax = other.MinMax.Clone();
              break;
            case ParamsOneofOneofCase.AffineParams:
              AffineParams = other.AffineParams.Clone();
              break;
          }

          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public PerAxisParams Clone() {
          return new PerAxisParams(this);
        }

        /// <summary>Field number for the "min_max" field.</summary>
        public const int MinMaxFieldNumber = 1;
        /// <summary>
        /// min/max of the ranges.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Mlir.Quant.QuantizationInfo.Types.MinMax MinMax {
          get { return paramsOneofCase_ == ParamsOneofOneofCase.MinMax ? (global::Mlir.Quant.QuantizationInfo.Types.MinMax) paramsOneof_ : null; }
          set {
            paramsOneof_ = value;
            paramsOneofCase_ = value == null ? ParamsOneofOneofCase.None : ParamsOneofOneofCase.MinMax;
          }
        }

        /// <summary>Field number for the "affine_params" field.</summary>
        public const int AffineParamsFieldNumber = 2;
        /// <summary>
        /// affine parameters to quantize the per axis value.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Mlir.Quant.QuantizationInfo.Types.AffineParams AffineParams {
          get { return paramsOneofCase_ == ParamsOneofOneofCase.AffineParams ? (global::Mlir.Quant.QuantizationInfo.Types.AffineParams) paramsOneof_ : null; }
          set {
            paramsOneof_ = value;
            paramsOneofCase_ = value == null ? ParamsOneofOneofCase.None : ParamsOneofOneofCase.AffineParams;
          }
        }

        private object paramsOneof_;
        /// <summary>Enum of possible cases for the "params_oneof" oneof.</summary>
        public enum ParamsOneofOneofCase {
          None = 0,
          MinMax = 1,
          AffineParams = 2,
        }
        private ParamsOneofOneofCase paramsOneofCase_ = ParamsOneofOneofCase.None;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public ParamsOneofOneofCase ParamsOneofCase {
          get { return paramsOneofCase_; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void ClearParamsOneof() {
          paramsOneofCase_ = ParamsOneofOneofCase.None;
          paramsOneof_ = null;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as PerAxisParams);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(PerAxisParams other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (!object.Equals(MinMax, other.MinMax)) return false;
          if (!object.Equals(AffineParams, other.AffineParams)) return false;
          if (ParamsOneofCase != other.ParamsOneofCase) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (paramsOneofCase_ == ParamsOneofOneofCase.MinMax) hash ^= MinMax.GetHashCode();
          if (paramsOneofCase_ == ParamsOneofOneofCase.AffineParams) hash ^= AffineParams.GetHashCode();
          hash ^= (int) paramsOneofCase_;
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (paramsOneofCase_ == ParamsOneofOneofCase.MinMax) {
            output.WriteRawTag(10);
            output.WriteMessage(MinMax);
          }
          if (paramsOneofCase_ == ParamsOneofOneofCase.AffineParams) {
            output.WriteRawTag(18);
            output.WriteMessage(AffineParams);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (paramsOneofCase_ == ParamsOneofOneofCase.MinMax) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(MinMax);
          }
          if (paramsOneofCase_ == ParamsOneofOneofCase.AffineParams) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(AffineParams);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(PerAxisParams other) {
          if (other == null) {
            return;
          }
          switch (other.ParamsOneofCase) {
            case ParamsOneofOneofCase.MinMax:
              if (MinMax == null) {
                MinMax = new global::Mlir.Quant.QuantizationInfo.Types.MinMax();
              }
              MinMax.MergeFrom(other.MinMax);
              break;
            case ParamsOneofOneofCase.AffineParams:
              if (AffineParams == null) {
                AffineParams = new global::Mlir.Quant.QuantizationInfo.Types.AffineParams();
              }
              AffineParams.MergeFrom(other.AffineParams);
              break;
          }

          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                global::Mlir.Quant.QuantizationInfo.Types.MinMax subBuilder = new global::Mlir.Quant.QuantizationInfo.Types.MinMax();
                if (paramsOneofCase_ == ParamsOneofOneofCase.MinMax) {
                  subBuilder.MergeFrom(MinMax);
                }
                input.ReadMessage(subBuilder);
                MinMax = subBuilder;
                break;
              }
              case 18: {
                global::Mlir.Quant.QuantizationInfo.Types.AffineParams subBuilder = new global::Mlir.Quant.QuantizationInfo.Types.AffineParams();
                if (paramsOneofCase_ == ParamsOneofOneofCase.AffineParams) {
                  subBuilder.MergeFrom(AffineParams);
                }
                input.ReadMessage(subBuilder);
                AffineParams = subBuilder;
                break;
              }
            }
          }
        }

      }

      /// <summary>
      /// The metadata defines the target properties.
      /// </summary>
      public sealed partial class Metadata : pb::IMessage<Metadata> {
        private static readonly pb::MessageParser<Metadata> _parser = new pb::MessageParser<Metadata>(() => new Metadata());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<Metadata> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Mlir.Quant.QuantizationInfo.Descriptor.NestedTypes[3]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Metadata() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Metadata(Metadata other) : this() {
          numBits_ = other.numBits_;
          quantizeAxis_ = other.quantizeAxis_;
          rangeMin_ = other.rangeMin_;
          rangeMax_ = other.rangeMax_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Metadata Clone() {
          return new Metadata(this);
        }

        /// <summary>Field number for the "num_bits" field.</summary>
        public const int NumBitsFieldNumber = 1;
        private int numBits_;
        /// <summary>
        ///  Bit number of fixed-point data the target kernel supports.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int NumBits {
          get { return numBits_; }
          set {
            numBits_ = value;
          }
        }

        /// <summary>Field number for the "quantize_axis" field.</summary>
        public const int QuantizeAxisFieldNumber = 2;
        private int quantizeAxis_;
        /// <summary>
        ///  The quantized axis index if it is per-axis quantization.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int QuantizeAxis {
          get { return quantizeAxis_; }
          set {
            quantizeAxis_ = value;
          }
        }

        /// <summary>Field number for the "range_min" field.</summary>
        public const int RangeMinFieldNumber = 3;
        private int rangeMin_;
        /// <summary>
        /// The minimum allowed value of the fixed-point data range.
        /// This can also be used to derive the sign of storage type.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int RangeMin {
          get { return rangeMin_; }
          set {
            rangeMin_ = value;
          }
        }

        /// <summary>Field number for the "range_max" field.</summary>
        public const int RangeMaxFieldNumber = 4;
        private int rangeMax_;
        /// <summary>
        /// The minimum allowed value of the fixed-point data range.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int RangeMax {
          get { return rangeMax_; }
          set {
            rangeMax_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as Metadata);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(Metadata other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (NumBits != other.NumBits) return false;
          if (QuantizeAxis != other.QuantizeAxis) return false;
          if (RangeMin != other.RangeMin) return false;
          if (RangeMax != other.RangeMax) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (NumBits != 0) hash ^= NumBits.GetHashCode();
          if (QuantizeAxis != 0) hash ^= QuantizeAxis.GetHashCode();
          if (RangeMin != 0) hash ^= RangeMin.GetHashCode();
          if (RangeMax != 0) hash ^= RangeMax.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (NumBits != 0) {
            output.WriteRawTag(8);
            output.WriteInt32(NumBits);
          }
          if (QuantizeAxis != 0) {
            output.WriteRawTag(16);
            output.WriteInt32(QuantizeAxis);
          }
          if (RangeMin != 0) {
            output.WriteRawTag(24);
            output.WriteInt32(RangeMin);
          }
          if (RangeMax != 0) {
            output.WriteRawTag(32);
            output.WriteInt32(RangeMax);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (NumBits != 0) {
            size += 1 + pb::CodedOutputStream.ComputeInt32Size(NumBits);
          }
          if (QuantizeAxis != 0) {
            size += 1 + pb::CodedOutputStream.ComputeInt32Size(QuantizeAxis);
          }
          if (RangeMin != 0) {
            size += 1 + pb::CodedOutputStream.ComputeInt32Size(RangeMin);
          }
          if (RangeMax != 0) {
            size += 1 + pb::CodedOutputStream.ComputeInt32Size(RangeMax);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(Metadata other) {
          if (other == null) {
            return;
          }
          if (other.NumBits != 0) {
            NumBits = other.NumBits;
          }
          if (other.QuantizeAxis != 0) {
            QuantizeAxis = other.QuantizeAxis;
          }
          if (other.RangeMin != 0) {
            RangeMin = other.RangeMin;
          }
          if (other.RangeMax != 0) {
            RangeMax = other.RangeMax;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 8: {
                NumBits = input.ReadInt32();
                break;
              }
              case 16: {
                QuantizeAxis = input.ReadInt32();
                break;
              }
              case 24: {
                RangeMin = input.ReadInt32();
                break;
              }
              case 32: {
                RangeMax = input.ReadInt32();
                break;
              }
            }
          }
        }

      }

      /// <summary>
      /// The quantization parameters for a named tensor.
      /// </summary>
      public sealed partial class QuantParams : pb::IMessage<QuantParams> {
        private static readonly pb::MessageParser<QuantParams> _parser = new pb::MessageParser<QuantParams>(() => new QuantParams());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<QuantParams> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Mlir.Quant.QuantizationInfo.Descriptor.NestedTypes[4]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public QuantParams() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public QuantParams(QuantParams other) : this() {
          params_ = other.params_.Clone();
          meta_ = other.meta_ != null ? other.meta_.Clone() : null;
          switch (other.NameOneofCase) {
            case NameOneofOneofCase.Name:
              Name = other.Name;
              break;
            case NameOneofOneofCase.NameRegex:
              NameRegex = other.NameRegex;
              break;
          }

          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public QuantParams Clone() {
          return new QuantParams(this);
        }

        /// <summary>Field number for the "name" field.</summary>
        public const int NameFieldNumber = 1;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string Name {
          get { return nameOneofCase_ == NameOneofOneofCase.Name ? (string) nameOneof_ : ""; }
          set {
            nameOneof_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
            nameOneofCase_ = NameOneofOneofCase.Name;
          }
        }

        /// <summary>Field number for the "name_regex" field.</summary>
        public const int NameRegexFieldNumber = 2;
        /// <summary>
        /// An regex can be used to match multiple tensors.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string NameRegex {
          get { return nameOneofCase_ == NameOneofOneofCase.NameRegex ? (string) nameOneof_ : ""; }
          set {
            nameOneof_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
            nameOneofCase_ = NameOneofOneofCase.NameRegex;
          }
        }

        /// <summary>Field number for the "params" field.</summary>
        public const int ParamsFieldNumber = 3;
        private static readonly pb::FieldCodec<global::Mlir.Quant.QuantizationInfo.Types.PerAxisParams> _repeated_params_codec
            = pb::FieldCodec.ForMessage(26, global::Mlir.Quant.QuantizationInfo.Types.PerAxisParams.Parser);
        private readonly pbc::RepeatedField<global::Mlir.Quant.QuantizationInfo.Types.PerAxisParams> params_ = new pbc::RepeatedField<global::Mlir.Quant.QuantizationInfo.Types.PerAxisParams>();
        /// <summary>
        /// The quantization parameters for the tensor. If it is for per-axis, the
        /// parameters should be defined for each axis, otherwise, if it is for
        /// per-tensor, this repeated field should only contain a single element.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<global::Mlir.Quant.QuantizationInfo.Types.PerAxisParams> Params {
          get { return params_; }
        }

        /// <summary>Field number for the "meta" field.</summary>
        public const int MetaFieldNumber = 5;
        private global::Mlir.Quant.QuantizationInfo.Types.Metadata meta_;
        /// <summary>
        /// Metadata about the quantization parameters.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Mlir.Quant.QuantizationInfo.Types.Metadata Meta {
          get { return meta_; }
          set {
            meta_ = value;
          }
        }

        private object nameOneof_;
        /// <summary>Enum of possible cases for the "name_oneof" oneof.</summary>
        public enum NameOneofOneofCase {
          None = 0,
          Name = 1,
          NameRegex = 2,
        }
        private NameOneofOneofCase nameOneofCase_ = NameOneofOneofCase.None;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public NameOneofOneofCase NameOneofCase {
          get { return nameOneofCase_; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void ClearNameOneof() {
          nameOneofCase_ = NameOneofOneofCase.None;
          nameOneof_ = null;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as QuantParams);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(QuantParams other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (Name != other.Name) return false;
          if (NameRegex != other.NameRegex) return false;
          if(!params_.Equals(other.params_)) return false;
          if (!object.Equals(Meta, other.Meta)) return false;
          if (NameOneofCase != other.NameOneofCase) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (nameOneofCase_ == NameOneofOneofCase.Name) hash ^= Name.GetHashCode();
          if (nameOneofCase_ == NameOneofOneofCase.NameRegex) hash ^= NameRegex.GetHashCode();
          hash ^= params_.GetHashCode();
          if (meta_ != null) hash ^= Meta.GetHashCode();
          hash ^= (int) nameOneofCase_;
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (nameOneofCase_ == NameOneofOneofCase.Name) {
            output.WriteRawTag(10);
            output.WriteString(Name);
          }
          if (nameOneofCase_ == NameOneofOneofCase.NameRegex) {
            output.WriteRawTag(18);
            output.WriteString(NameRegex);
          }
          params_.WriteTo(output, _repeated_params_codec);
          if (meta_ != null) {
            output.WriteRawTag(42);
            output.WriteMessage(Meta);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (nameOneofCase_ == NameOneofOneofCase.Name) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
          }
          if (nameOneofCase_ == NameOneofOneofCase.NameRegex) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(NameRegex);
          }
          size += params_.CalculateSize(_repeated_params_codec);
          if (meta_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(Meta);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(QuantParams other) {
          if (other == null) {
            return;
          }
          params_.Add(other.params_);
          if (other.meta_ != null) {
            if (meta_ == null) {
              Meta = new global::Mlir.Quant.QuantizationInfo.Types.Metadata();
            }
            Meta.MergeFrom(other.Meta);
          }
          switch (other.NameOneofCase) {
            case NameOneofOneofCase.Name:
              Name = other.Name;
              break;
            case NameOneofOneofCase.NameRegex:
              NameRegex = other.NameRegex;
              break;
          }

          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                Name = input.ReadString();
                break;
              }
              case 18: {
                NameRegex = input.ReadString();
                break;
              }
              case 26: {
                params_.AddEntriesFrom(input, _repeated_params_codec);
                break;
              }
              case 42: {
                if (meta_ == null) {
                  Meta = new global::Mlir.Quant.QuantizationInfo.Types.Metadata();
                }
                input.ReadMessage(Meta);
                break;
              }
            }
          }
        }

      }

    }
    #endregion

  }

  #endregion

}

#endregion Designer generated code
